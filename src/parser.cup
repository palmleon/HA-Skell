import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Stack;
import java.util.Iterator;

parser code {:

	private String outputFileName;

	public boolean noCompileErrors = true;
	
	/* Next Line and Next Column Index (the parser is LALR(1)), so the last symbol scanned is the following one */
	public int nextLine, nextColumn;
	/* Current Line and Column Index (i.e. yyline() and yycolumn() in JFlex) */
	public int currLine = 0, currColumn = 0;
	
	/*
	 *  Define the name of the output file, containing the final Intermediate Representation in LLVM
	 *	@param: String outputFileName - name of the output file
	 *	@return: nothing
	 */
	public void setOutputFileName(String outputFileName) {
		this.outputFileName = outputFileName;
	}
	
	/* 
	 * 	Default Cup Function for reporting Syntax Errors
	 *  @param: java_cup.runtime.Symbol current - The last parsed symbol before raising the last Syntax Error 
	 *  @return: nothing
	 */
	public void syntax_error(java_cup.runtime.Symbol current) {
		report_error(current);
	}
	
	/*
	 * Function to retrieve values directly from the Stack
	 * @param: int position - position wrt the top of the Stack
	 * @return: Object - the corresponding element of the Stack 
	 */
    public Object stack(int position) {
        return (((Symbol)stack.elementAt(tos+position)).value);
    }
	
	/* 
	 *  Inform the user that a Syntax Error has been raised, and inform them about the nature of the Syntax Error
	 *	@param: Object info - The last parsed symbol before raising the last Syntax Error
	 *  		String msg - The additional message describing the kind of Syntax Error
	 *	@return: nothing
	 */
    public void report_error(Object info) {
		noCompileErrors = false;
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left);
                int column = (((Symbol)info).right);
                System.err.print(" (line "+line+", column "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
	
	/*
	 * Inform the user what caused a Syntax Error
	 * @param: String msg - the error msg
	 * @return: nothing
	 */
	public void report_syntax_error(String msg) {
		noCompileErrors = false;
		System.err.println(msg);
	}
	
	public void report_semantic_error(String msg) {
		noCompileErrors = false;
		System.err.print("ERROR: Semantic error");
        System.err.println(" (line "+currLine+", column "+currColumn+"): " + msg);
        //CUP$Parser$actions.SymTableStack.dumpSymTableStack();
	}
	
:};

action code {:

	/*
	 * Boolean flag that provides additional information for debugging purposes, when raised
	 */
	public static boolean debug_mode = true; 
	
	/* 
	 * Class for the Type Tree
	 * The following Class defines the Type structure
	 * Fields: String typeName - unique name for the Type
	 * 		   Type[] - list containing all the subtypes for an instance of a compound type 
	 *				(useful for functions, lists, tuples and any additional compound type) 
	 *		   Hashmap<String, Type> typeMap - a map containg, for any typeName, the corresponding standard Type
	 *				(initialized at Parser initialization time)
	 */
	public static class Type {
		
		private String typeName;
		private Type[] typeParams; //better than an ArrayList because its size it's fixed
		
		/* Basic Copy Constructor */
		Type(String typeName, Type[] typeParams) {
			this.typeName = typeName;
			this.typeParams = typeParams; // most types should have up to 2 type params
		}
		
		/* (Recursive) Copy Constructor */
		Type(Type type) {			
			int length = type.getTypeParams().length;
			this.typeName = type.getTypeName();
			this.typeParams = new Type[length];
			for (int i = 0; i < length; i++) {
				this.typeParams[i] = new Type(type.getTypeParams()[i]);
			}
		}
		
		/* Setter method for typeName */
		public void setTypeName(String typeName) {
			this.typeName = typeName;
		}
		
		
		/* Setter method for typeParams */
		public void setTypeParams(Type[] typeParams){
			this.typeParams = typeParams;
		}
		
		/* Setter method for the single child */
		public void setTypeParam(int pos, Type child) {
			this.typeParams[pos] = child;
		}
		
		/* Getter method for typeName */
		public String getTypeName(){
			return this.typeName;
		}
		
		/* Getter method for typeParams */
		public Type[] getTypeParams(){
			return this.typeParams;
		}
		
		/* Getter method for the single child */
		public Type getTypeParam(int pos) {
			return this.typeParams[pos];
		}
		
		/* 
		 * Method for Type Widening
		 * This Method is asymmetric: it takes the first type and tries to upcast it into the second one
		 * @param: String typeName1, typeName2 - the types to be compared
		 * Returns: The resulting widened type (null if widening is not possible) //TODO
		 */
		public static String widen(String typeName1, String typeName2) {
			String res = null;
			if (typeName1.equals(typeName2)) res = typeName1;
			else if (typeName1.equals("Int") && typeName2.equals("Double")) res = "Double";
			return res;
		}
		
		/* Method that checks Subtyping
		 * In Haskell, Type Hierarchy is not defined; instead, Hierarchy is represented by Typeclasses
		 * and their relationship.
		 * In this version of the Language, Typeclasses are not supported, so it is defined a simple
		 * Type Hierarchy where:
		 * - Any represents Type Variables (i.e. Java Generics)
		 * - Int is a subtype of Double
		 * The widen Method checks Subtyping for the single TreeNode
		 * @param: String other - the type to be compared with the calling one
		 * Returns: Boolean - true if other is Parent of this, false otherwise
		 */
		public boolean isSubtype(String other) {
			boolean isSubtype = true;
			if (other.equals("error")) return false;
			if (other.equals("Any")) return true;
			Type type = Type.getType(other);
			if (type == null) return false;
			if (Type.widen(this.getTypeName(), type.getTypeName()) == null) return false;
			if (this.getTypeParams().length != type.getTypeParams().length) return false;
			for (int i = 0; i < this.getTypeParams().length; i++) {
				isSubtype = isSubtype && this.getTypeParam(i).isSubtype(type.getTypeParam(i).getTypeName());
			}
			return isSubtype;
		}
		
		/* 
		 * Method for Type Equivalence Checking
		 * The isSubtype relationship is a Partial Ordering Relation, 
		 * Type Equivalence is equivalent to checking that 
		 * the first type is a subtype of the second one and viceversa.
		 * @param: String other - the type to compare with the calling one
		 * Returns: Boolean - true if the Trees are equivalent, false otherwise
		 */
		 
		public boolean isEquivalent(String other) {
			Type otherTree = Type.getType(other);
			if (otherTree == null) return false;
			return this.isSubtype(other) && otherTree.isSubtype(this.getTypeName());
		}
		
		/* 
		 * Additional Method for Type Equivalence Checking
		 * @param: Type other - the tree of the type to compare with the calling one
		 * Returns: Boolean - true if the Trees are equivalent, false otherwise
		 */
		public boolean isEquivalent(Type other) {
			return this.isEquivalent(other.getTypeName());
		}
		
		/*
		 * Static TypeMap that contains all the declared Types (allows to define custom Data Types), which is initialized during Parser initialization
		 */
		private static HashMap<String, Type> typeMap = new HashMap<>();
		
		/*
		 * Create TypeMap with the predefined available Types
		 * @param: nothing
		 * @return: nothing
		 */
		private static void createTypeMap() {
			// childType is used only for making the code slightly more readable
			Type type = new Type("Int", new Type[0]);
			Type.addType(type.getTypeName(), type);
			type = new Type("Double", new Type[0]);
			Type.addType(type.getTypeName(), type);
			type = new Type("Bool", new Type[0]);
			Type.addType(type.getTypeName(), type);
			type = new Type("Char", new Type[0]);
			Type.addType(type.getTypeName(), type);
			Type[] typeArray = { new Type(type) };
			type = new Type("List", typeArray);
			Type.addType("String", type);
			Type anyType = new Type("Any", new Type[0]); 
			typeArray = new Type[]{ new Type(anyType) };
			type = new Type("List", typeArray);
			Type.addType(type.getTypeName(), type);
			typeArray = new Type[]{ new Type(anyType), new Type(anyType) };
			type = new Type("Function", typeArray);
			Type.addType(type.getTypeName(), type);
			// special error type for propagating type checking errors
			type = new Type("error", new Type[0]);
			Type.addType(type.getTypeName(), type);
			// Min Arity for Tuples = 2, Max Arity for Tuples = 10
			/*for (int i = 2; i <= 10; i++) {
				typeArray = new Type[i];
				for (int j = 0; j < i; j++) {
					typeArray[j] = new Type(anyType);
				}	
				type = new Type("Tuple" + i, typeArray); 
				Type.addType(type.getTypeName(), type);
			}*/
		}
		
		/* 
		 * Insert a new Type inside the typeMap (if already present, the new one is discarded and a Semantic Error should arise)
		 * @param: String typeName - the name of the new Type
		 * 		   Type type - the corresponding type 
		 * @return: boolean - true if no error occured, false otherwise
		 */
		public static boolean addType(String typeName, Type type) {
			if (typeMap.containsKey(typeName)) return false;
			typeMap.put(typeName, type);
			return true;
		}
		
		/* 
		 * Check whether a certain type has been defined or not
		 * @param: String typeName - the type to look for
		 * @return: boolean - true if the type exists, false otherwise
		 */
		public static boolean typeExists(String typeName) {
			return typeMap.containsKey(typeName);
		}
		
		/* 
		 * Retrieve a clone of the Type of a specific type from the typeMap, if present
		 * @param: String typeName - the name of the Type
		 * @return: the corresponding typeTree if the Type exists, null otherwise
		 */
		public static Type getType(String typeName) {
			if (typeMap.containsKey(typeName))
				return new Type(typeMap.get(typeName));
			else return null;
		}
		
		/*
		 * Debugging method for dumping the whole TypeMap TODO
		 * @param: nothing
		 * Returns: nothing
		 */
		public static void dumpTypeMap(){
			System.out.println("DEBUG: PRINTING TYPEMAP!");
			typeMap.forEach
				( (k, v) -> {
					System.out.println("TopTypeName: " + k);
					v.dumpType(0);
				} );
		}
		
		/*
		 * Debugging method for dumping a single Type TODO
		 * @param: int level - defines the level inside the Type, used for hierarchical printing of the Tree
		 * Returns: nothing
		 */
		private void dumpType(int level){
			for (int i = 0; i < level; i++)
				System.out.print("\t");
			System.out.println("-> " + this.getTypeName());
			for (int i = 0; i < this.getTypeParams().length; i++) {
				this.getTypeParam(i).dumpType(level+1);
			}
		}
		
		/* 
		 * Being the project not originally developed using an IDE, using JUnit is not the best option
		 * It would be ideal to move testing there (TODO)
		 */
		public static void testType() {
			// Check Type(Type type)
			// 		 isEquivalent, isSubtype
			Type type1 = Type.getType("List");
			Type type2 = new Type(type1);
			if (type1.isEquivalent(type2.getTypeName()))
				System.out.println("TEST TYPE TREE 1: PASSED");
			else
				System.out.println("TEST TYPE TREE 1: FAILED");
			// Check isSubtype, setTypeParam, getType
			Type type3 = Type.getType("List");
			type3.setTypeParam(0, Type.getType("Int"));
			if (type3.isSubtype("List"))
				System.out.println("TEST TYPE TREE 2: PASSED");
			else
				System.out.println("TEST TYPE TREE 2: FAILED");
			Type type4 = Type.getType("Int");
			Type type5 = Type.getType("Double");
			if (type4.isSubtype(type5.getTypeName()) && !type5.isSubtype(type4.getTypeName()))
				System.out.println("TEST TYPE TREE 3: PASSED");
			else
				System.out.println("TEST TYPE TREE 3: FAILED");
		}
	}
	
	/* Class for the Symbol Table Stack
	 * The following Class contains a Static instance of the SymTable Stack, together with methods
	 * that allow to push/pop SymTables and to extract an Entry from them
	 * Fields: symTableStack - the Static instance of the SymTable Stack
	 */
	public static class SymTableStack {
		
		/* Class for Symbol Table Entry
		 * All Entries inside any SymTable are instances of this Class
		 * Fields: Type type - type of the value/function
		 *		   boolean isAssigned - flag that checks whether the value/function has been assigned or not
		 */
		private static class SymTableEntry {
			
			private Type type;
			private boolean isAssigned;
			
			/* TODO UNCOMMENT WHEN GENERATING IR
			// corresponding name in the intermediate representation
			String llvm;
			*/
			
			SymTableEntry(Type type) {
				this.type = type;
				this.isAssigned = false;
			}
			
			SymTableEntry(Type type, boolean isAssigned) {
				this.type = type;
				this.isAssigned = isAssigned;
			}
			
			public Type getType() {
				return this.type;
			}
			
			public boolean getIsAssigned() {
				return this.isAssigned;
			}
			
			public void setType(Type type) {
				this.type = type;
			}
			
			public void setIsAssigned(boolean isAssigned) {
				this.isAssigned = isAssigned;
			}
		}
		
		// Symbol Table Stack (there is only one global instance whose lifetime corresponds to the lifetime of the parser itself)
		private static LinkedList<HashMap<String, SymTableEntry>> symTableStack = new LinkedList<>();
		
		// Data Structure that contains, for all current SymTables (i.e. for all levels) in the Stack, their Id (i.e. how many times a SymTable has been defined at that level
		// This Data Structure is used for generating unique names for variables during IR Generation
		private static ArrayList<Integer> symTableStackId = new ArrayList<>();
		
		/*
		 * Update the indexes in the symTableStackId list
		 * It is called every time that a new SymTable is pushed
		 * The method increments the index corresponding to the level 
		 * of the last inserted symTable
		 * @param: nothing
		 * @return: nothing
		 */
		public static void updateSymTableStackId() {
			int stackSize = symTableStack.size();
			int stackIdSize = symTableStackId.size();
			if (stackSize > stackIdSize) {
				symTableStackId.add(0);
			}
			// increment the index of the top level symTable (it's the only new one)
			int currSymTableId = symTableStackId.get(stackSize-1);
			symTableStackId.set(stackSize - 1, currSymTableId + 1);
		}
		
		/*
		 * Obtain a String as a sequence of strings in the form "${symTableId}",
		 * where symTableId is the index of the corresponding level of the SymTable
		 * @param: int valueLevel - the level where the Value/Function is declared
		 * @return: String - the sequence of "${symTableId}" strings, as a single string
		 */
		public static String getSymTableIds(int valueLevel) {
			String symTableIds = new String();
			int level = 0;
			Iterator<HashMap<String, SymTableEntry>> iterator = symTableStack.descendingIterator();
			HashMap<String, SymTableEntry> symTable;
			while (iterator.hasNext() && level <= valueLevel) {
				symTable = iterator.next();
				if (level > 0) {	
					symTableIds += "$" + symTableStackId.get(level);
				}
				level++;
			}
			return symTableIds;
		}
		
		/*
		 * Create a unique Id for IR Code Generation
		 * A unique Id is composed of:
		 * - the name of the Value/Function itself
		 * - a sequence of strings in the form "${symTableId}"
		 * @param:  String id - the Value/Function name
		 * @return: String - the unique Id
		 */
		public static String createUniqueId(String id) {
			return id + getSymTableIds(SymTableStack.getLevel(id));
		}
		
		/* 
		 * Method that pushes a new SymTable to the Stack
		 * @param: nothing
		 * @return: nothing
		 */
		public static void pushSymTable() {
			symTableStack.push(new HashMap<String, SymTableEntry>());
			updateSymTableStackId();
		}
		
		/* 
		 * Method that pops the SymTable on top of the Stack
		 * @param: nothing
		 * @return: nothing
		 */
		public static void popSymTable() {
			if(debug_mode) dumpSymTableStack();
			symTableStack.pop();
		}
		
		/*
		 * Extract the SymTable on top of the Stack
		 * @param: nothing
		 * @return: the expected SymTable
		 */
		public static HashMap<String, SymTableEntry> peekSymTable() {
			return symTableStack.peek();
		}
		
		/*
		 * Insert a new Entry in the SymTable on top of the Stack
		 * This method is sensitive to the context (it depends on the current position in the Parser Tree)
		 * The Parser must guarantee the correct SymTable for a given Entry
		 * @param: String id - the name of the Entry (the corresponding token)
		 * 		   SymTableEntry entry - the Entry
		 * @return: nothing
		 */
		public static void putEntry(String id, SymTableEntry entry) {
			symTableStack.peek().put(id, entry);
		}
		
		/*
		 * Check whether a certain Entry is present in the whole SymTable Stack
		 * Search is applied from the top of the Stack to the bottom;
		 * the first match is considered
		 * @param: String id - the name of the Entry (the corresponding token)
		 * @return: the flag that indicates whether the Entry is present or not
		 */
		public static boolean containsEntry(String id) {
			boolean entryFound = false; // flag, raised if an Entry having the same name as id is found
			Iterator<HashMap<String, SymTableEntry>> iterator = symTableStack.listIterator(0);
			while (!entryFound && iterator.hasNext()) {
				if (iterator.next().containsKey(id)) entryFound = true;
			}
			return entryFound;
		}
		
		/*
		 * Check whether a certain Entry is present in the whole SymTable Stack and return it
		 * Search is applied from the top of the Stack to the bottom;
		 * the first match is considered
		 * @param: String id - the name of the Entry (the corresponding token)
		 * @return: the Entry itself, if found (null otherwise)
		 */
		public static SymTableEntry getEntry(String id) {
			Iterator<HashMap<String, SymTableEntry>> iterator = symTableStack.listIterator(0);
			while (iterator.hasNext()) {
				HashMap<String, SymTableEntry> currentSymTable = iterator.next();
				if (currentSymTable.containsKey(id)) return currentSymTable.get(id);
			}
			return null;
		}
		
		/*
		 * Get level of the argument Id in the SymTable Stack
		 * @param: String id - the argument Id
		 * @return: int - the level in the SymTable Stack
		 */
		public static int getLevel(String id) {
			Iterator<HashMap<String, SymTableEntry>> iterator = symTableStack.listIterator(0);
			int entryLevel = -1, level = symTableStack.size()-1;
			while (iterator.hasNext()) {
				HashMap<String, SymTableEntry> currentSymTable = iterator.next();
				if (currentSymTable.containsKey(id)) entryLevel = level;
				level--;
			}
			return entryLevel;
		}
		
		/*
		 * Debugging method that prints out the content of the whole symTableStack 
		 * @param: nothing
		 * @return: nothing
		 */
		public static void dumpSymTableStack(){
			int level = symTableStack.size()-1;
			Iterator<HashMap<String, SymTableEntry>> iterator = symTableStack.listIterator(0);
			System.out.println("DEBUG: PRINTING SYMTABLESTACK!");
			while (iterator.hasNext()){
				System.out.println("Level " + level);
				iterator.next().forEach
					( (k, v) -> { 
						System.out.print("->");
						System.out.println(" Name: " + k + ", isAssigned: " + v.getIsAssigned());
						v.getType().dumpType(1);
					});
				level--;
			}
		}
		
		/* 
		 * Being the project not originally developed using an IDE, using JUnit is not the best option
		 * It would be ideal to move testing there (TODO)
		 */
		public static void testSymTableStack() {
			SymTableStack.pushSymTable();
			Type type = Type.getType("Int");
			SymTableStack.putEntry("x", new SymTableEntry(type));
			SymTableStack.putEntry("y", new SymTableEntry(type));
			if (SymTableStack.containsEntry("x")) 
				System.out.println ("TEST SYMTABLE STACK 1: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 1: FAILED");
			if (!SymTableStack.containsEntry("xx")) 
				System.out.println ("TEST SYMTABLE STACK 2: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 2: FAILED");
			if (SymTableStack.getEntry("x") != null)
				System.out.println ("TEST SYMTABLE STACK 3: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 3: FAILED");
			if (SymTableStack.getEntry("xx") == null) 
				System.out.println ("TEST SYMTABLE STACK 4: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 4: FAILED");
			boolean isPresent = SymTableStack.getEntry("x").getIsAssigned();
			if (!isPresent)
				System.out.println ("TEST SYMTABLE STACK 5: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 5: FAILED");
			SymTableStack.pushSymTable();
			Type xTree = Type.getType("Double");
			SymTableStack.putEntry("x", new SymTableEntry(xTree));
			SymTableEntry entry = SymTableStack.getEntry("x");
			if (entry != null && entry.getType().isEquivalent("Double"))
				System.out.println ("TEST SYMTABLE STACK 6: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 6: FAILED");
 			SymTableStack.popSymTable();
		}
		
	}
	
	/*
	 * Check whether a value/function is global or not
	 * @param: String id - the value/function name
	 * @return: boolean - the boolean result
	 */
	public boolean isGlobal(String id) {
		if(!isDeclared(id)) return false;
		return SymTableStack.getLevel(id) == 0;
	}
	
	/*
	 * Method that implements Uniqueness check, i.e. verifies whether a variable has already been declared in
	 * currentSymTable or not
	 * @param: String entryName - the name of the value whose uniqueness needs to be checked
	 * @return: boolean - true if the value is unique, false otherwise
	 */
	public boolean isLocallyDeclared(String entryName) {
		return SymTableStack.peekSymTable().containsKey(entryName);
	}
	
	/*
	 * Method that implements Assignment Uniqueness check, i.e. verifies whether a variable has already been assigned
	 * @param: String entryName - the name of the value whose assignment uniqueness needs to be checked
	 * @return: boolean - true if the value has not been assigned yet, false otherwise
	 */
	public boolean isAssigned(String entryName) {
		return SymTableStack.getEntry(entryName).getIsAssigned();
	}
	
	/*
	 * Method that implements Arity check, i.e. verifies whether the function has the same arity of its actual arguments
	 * No check is performed on whether funcName actually holds the name of a Function
	 * The method traverses the Function Tree, following the Function nodes until only Non-Function nodes are found
	 * @param:  String funcName - the name of the function whose Arity needs to be checked
	 * 			int arity - the expected Arity of the function
	 * @return: boolean - true if the function has the same Arity, false otherwise
	 */
	public boolean hasArity(String funcName, int arity) {
		int count = 1;
		Type funcType = SymTableStack.getEntry(funcName).getType();
		Type rightTypeParam = funcType.getTypeParam(1);
		while(rightTypeParam.isSubtype("Function")) {
			count++;
			rightTypeParam = rightTypeParam.getTypeParam(1);
		}
		return count == arity;
	}
	
	/*
	 * Method that returns the @return Type of a Function
	 * Checking that funcName actually refers to a Funcion is up to other Semantic Rules
	 * @param: String funcName - the Function whose @return Type is required
	 * @return: Type - the Type of the @return Type
	 */
	public Type returnType(String funcName) {
		Type funcType = SymTableStack.getEntry(funcName).getType();
		return returnType(funcType);
	}
	
	/*
	 * Method that returns the @return Type of a Function
	 * Checking that the argument actually refers to a Funcion is up to other Semantic Rules
	 * @param: Type type - the Function whose @return Type is required
	 * @return: Type - the Type of the @return Type
	 */
	public Type returnType(Type type) {
		Type rightTypeParam = type.getTypeParam(1);
		while(rightTypeParam.isSubtype("Function")) {
			rightTypeParam = rightTypeParam.getTypeParam(1);
		}
		return rightTypeParam;
	}
	
	/* 
	 * Method that implements Declaration check, i.e. verifies whether a variable has been declared in the whole program,
	 * since LHC supports Static Lexical Scoping
	 * @param: String entryName - the name of the value whose declaration needs to be checked
	 * @return: boolean - true if the value has been already declared, false otherwise
	 */
	public boolean isDeclared(String entryName) {
		return SymTableStack.containsEntry(entryName);
	}
	
	/// Classes for building the AST, used for Semantic Analysis and IR Codegen
	 
	/*
	 * Basic 
	 */
	public abstract static class BasicNodeAST {
		LinkedList<String> code = new LinkedList<>();
		
		abstract String codegen();
		
		void mountCode(BasicNodeAST otherNode) {
			this.code.addAll(otherNode.code);
		}
	}
	 
	public static class ProgramAST extends BasicNodeAST {
		FunctPartAST functPart;
		ImperPartAST imperPart;
		
		ProgramAST(FunctPartAST functPart, ImperPartAST imperPart) {
			this.functPart = functPart;
			this.imperPart = imperPart;
		}
		
		@Override
		String codegen() {
			functPart.codegen();
			mountCode(functPart);
			imperPart.codegen();
			mountCode(imperPart);
			return null;
		}
		
	}
	
	public static class FunctPartAST extends BasicNodeAST {
		LinkedList<StmtAST> stmts;
		
		FunctPartAST(LinkedList<StmtAST> stmts) {
			this.stmts = stmts;
		}
		
		@Override
		String codegen() {
			for (StmtAST stmt: stmts) {
				stmt.codegen();
				mountCode(stmt);
			}
			return null;
		}
	}
	
	public static class ImperPartAST extends BasicNodeAST {
		IOActionAST ioAction;
		
		ImperPartAST(IOActionAST ioAction) {
			this.ioAction = ioAction;
		}
		
		@Override
		String codegen() { 
			LLVM.resetCounterSSA();
			LFormArgAST lformarg = new LFormArgAST(new ArrayList<String>(), new ArrayList<Type>(), null); 
			code.add(LLVM.createPrintDeclaration());
			code.addAll(LLVM.createPrintFormatStrings());
			code.add(LLVM.createMainDefinition());
			code.addAll(LLVM.openFunction());
			ioAction.codegen();
			mountCode(ioAction);
			code.add(LLVM.createReturnVoid());
			code.add(LLVM.closeFunction());
			return null;
		}
	}
	
	/* 
	 * IOAction is currently empty, but it could be extended (e.g. by including
	 * the type of the content of the last IOAction
	 */ 
	public abstract static class DoStmtAST extends BasicNodeAST {}
	
	public abstract static class IOActionAST extends DoStmtAST {}
	
	public static class PrintAST extends IOActionAST {
		ExprAST actarg;
		
		PrintAST(ExprAST actarg) {
			this.actarg = actarg;
		}
		
		@Override
		String codegen() { 
			int result = actarg.codegen();
			mountCode(actarg);
			code.addAll(LLVM.createPrintCall(result, actarg.type));
			return null;
		}
	}
	
	public static class DoBlockAST extends IOActionAST {
		LinkedList<DoStmtAST> ioActions;
		
		DoBlockAST(LinkedList<DoStmtAST> ioActions) {
			this.ioActions = ioActions;
		}
		
		@Override
		String codegen() { 
			for (DoStmtAST ioAction: ioActions) {
				ioAction.codegen();
				mountCode(ioAction);
			}
			return null;
		}
	}
	
	public static class IfBlockImperAST extends IOActionAST{
		ExprAST cond;
		IOActionAST thenBody;
		IOActionAST elseBody;
		
		IfBlockImperAST(ExprAST cond, IOActionAST thenBody, IOActionAST elseBody) {
			this.cond 	  = cond;
			this.thenBody = thenBody;
			this.elseBody = elseBody;
		}
		
		@Override
		String codegen() {
			final int ifIndex, condIndex;
			ifIndex = LLVM.getCounterIf();
			LLVM.updateCounterIf();
			condIndex = cond.codegen();
			mountCode(cond);
			code.add(LLVM.createBranchCond(condIndex, "if.then." + ifIndex, "if.else." + ifIndex));
			code.add(LLVM.createLabel("if.then." + ifIndex));
			thenBody.codegen();
			mountCode(thenBody);
			code.add(LLVM.createBranchNotCond("if.exit." + ifIndex));
			code.add(LLVM.createLabel("if.else." + ifIndex));
			elseBody.codegen();
			mountCode(elseBody);
			code.add(LLVM.createBranchNotCond("if.exit." + ifIndex));
			code.add(LLVM.createLabel("if.exit." + ifIndex));
			return null;
		}
	}
	
	public static class LetBlockImperAST extends DoStmtAST {
		LinkedList<StmtAST> letStmts;
		
		LetBlockImperAST(LinkedList<StmtAST> letStmts) {
			this.letStmts = letStmts;
		}
		
		@Override
		String codegen() {
			for (StmtAST letStmt: letStmts) {
				letStmt.codegen();
				mountCode(letStmt);
			}
			return null;
		}
	}
	
	public abstract static class StmtAST extends BasicNodeAST {}
		
	public static class DeclTypeAST extends StmtAST {
		Type type; // Used to propagate Type over multiple Type Declaration on the same line
		
		DeclTypeAST (Type type) {
			this.type = type;
		}
		
		@Override
		String codegen() { return null;}
	}
	
	public static class DefValueAST extends StmtAST {
		String id; // must be a "unique" id
		ExprAST expr;
		
		DefValueAST(String id, ExprAST expr) {
			this.id = SymTableStack.createUniqueId(id);
			this.expr = expr;
		}
		
		@Override
		String codegen() { 
			final exprIndex = expr.codegen();
			mountCode(expr);
			code.add(LLVM.createAlloca(id, expr.type));
			code.add(LLVM.createStore(id, exprIndex, expr.type));
			return null;
		}
	}
	
	public static class DefFunctAST extends StmtAST {
		String id; // must be a "unique" id
		LFormArgAST lformarg;
		ExprAST expr;
		
		DefFunctAST(String id, LFormArgAST lformarg, ExprAST expr) {
			this.id = SymTableStack.createUniqueId(id);
			this.lformarg = lformarg;
			this.expr = expr;
		}
		
		@Override
		String codegen() { 
			LLVM.resetCounterSSA();
			code.add(LLVM.createFunctionDefinition(id, expr.type, lformarg));
			code.addAll(LLVM.openFunction());
			String result = expr.codegen();
			mountCode(expr);
			code.add(LLVM.createReturn(result, expr.type));
			code.add(LLVM.closeFunction());
			return null;
		}
	}
	
	public abstract static class BasicExprAST extends BasicNodeAST {
		Type type;
	}
	
	public enum ExprKind {
			PLUS, MINUS, TIMES, DIV, INTDIV, MOD, AND, OR,
			RELNOTEQ, RELEQ, RELGE, RELGT, RELLE, RELLT,
			LENGTH, INDEX, NOT, UMINUS, LET_BLOCK_FUNC,
			IF_BLOCK_FUNC, FUNCT_CALL, VALUE, EXPR_LIST
	}
	
	public static class ExprAST extends BasicExprAST {
		
		ExprKind exprKind;
		BasicExprAST[] subExpressions; //the subexpressions
		
		ExprAST (Type type, ExprKind exprKind, BasicExprAST[] subExpressions) {
			this.type = type;
			this.exprKind = exprKind;
			this.subExpressions = subExpressions;
		}
		
		@Override
		String codegen() {	// TO BE COMPLETED
			String result;
			switch (exprKind) {
				case PLUS: break;
				case MINUS: break;
				case TIMES: break;
				case DIV: break;
				case INTDIV: break;
				case MOD: break;
				case AND: break;
				case OR: break;
				case RELNOTEQ: break;
				case RELEQ: break;
				case RELGE: break;
				case RELGT: break;
				case RELLE: break;
				case RELLT: break;
				case LENGTH: break;
				case INDEX: break;
				case NOT: break;
				case UMINUS: break;
				case LET_BLOCK_FUNC: break;
				case IF_BLOCK_FUNC: break;
				case FUNCT_CALL: break;
				case VALUE: break;
				case EXPR_LIST: break;
			}
			return 0;
		}
	}
	
	public static class LetBlockFuncAST extends BasicExprAST {
		LinkedList<StmtAST> letStmts;
		ExprAST expr;
		
		LetBlockFuncAST(Type type, LinkedList<StmtAST> letStmts, ExprAST expr) {
			this.type = type;
			this.letStmts = letStmts;
			this.expr = expr;
		}
		
		@Override
		String codegen() { 
			for (StmtAST letStmt: letStmts) {
				letStmt.codegen();
				mountCode(letStmt);
			}
			String result = expr.codegen();
			mountCode(expr);
			return result;
		}
	}
	
	public static class IfBlockFuncAST extends BasicExprAST {
		ExprAST cond, thenBody, elseBody;
		
		IfBlockFuncAST(Type type, ExprAST cond, ExprAST thenBody, ExprAST elseBody) {
			this.type = type;
			this.cond = cond;
			this.thenBody = thenBody;
			this.elseBody = elseBody;
		}
		
		@Override
		String codegen() { 
			final int ifIndex;
			String condIndex, thenIndex, elseIndex, result;
			ifIndex = LLVM.getCounterIf();
			LLVM.updateCounterIf();
			condIndex = cond.codegen();
			mountCode(cond);
			code.add(LLVM.createBranchCond(condIndex, "if.then." + ifIndex, "if.else." + ifIndex));
			code.add(LLVM.createLabel("if.then." + ifIndex));
			thenIndex = thenBody.codegen();
			mountCode(thenBody);
			code.add(LLVM.createBranchNotCond("if.exit." + ifIndex));
			code.add(LLVM.createLabel("if.else." + ifIndex));
			elseIndex = elseBody.codegen();
			mountCode(elseBody);
			code.add(LLVM.createBranchNotCond("if.exit." + ifIndex));
			code.add(LLVM.createLabel("if.exit." + ifIndex));
			result = LLVM.getCounterSSA().toString(); LLVM.updateCounterSSA();
			code.add(LLVM.createPHINode(result, this.type, "if.then." + ifIndex, thenIndex, "if.else." + ifIndex, elseIndex));
			return result;
		}
	}
	
	/*
	 * Includes both global variables and functions
	 */
	public static class FunctCallAST extends BasicExprAST {
		String id; // must be a unique id
		LinkedList<ExprAST> actargs;
		
		FunctCallAST(Type type, String id, LinkedList<ExprAST> actargs) {
			this.type = type;
			this.id = SymTableStack.createUniqueId(id);
			this.actargs = actargs;
			//System.out.println("DEBUG: FUNCTION CALL ON " + this.id); 
		}
		
		@Override
		String codegen() {
			ArrayList<Integer> argIds = new ArrayList<>(); // list containing all the input argument id for the function
			ArrayList<Type> argTypes = new ArrayList<>();
			String result;
			for (ExprAST actarg: actargs) {
				argIds.add(actarg.codegen());
				argTypes.add(actarg.type);
				mountCode(actarg);
			}
			if (id.contains("$")) { // only local values have a '$' appended to their name
				result = LLVM.getCounterSSA().toString(); LLVM.updateCounterSSA();
				code.add(LLVM.createLoad(result, this.type, id));
			}
			else {
				result = LLVM.getCounterSSA().toString(); LLVM.updateCounterSSA(); 
				code.add(LLVM.createFunctionCall(result, this.type, id, argIds, argTypes));
			}
			return result;
		}
	}
	
	/* Value is:
	 *	- Basic type for basic types (Int, Double, Char, String, Bool)
	 */
	public static class ValueAST extends BasicExprAST{
		Object value;
		
		ValueAST (Type type, Object value) {
			this.type = type;
			this.value = value;
		}
		
		@Override
		String codegen() { 
			String result;
			// trivial constants are just reported as they are and directly put
			// onto the code
			if (type.isEquivalent("Int")) {
				result = (Integer) value.toString();
			}
			else if (type.isEquivalent("Double")) {
				result = (Double) value.toString();
			}
			else if (type.isEquivalent("Char")) {
				// chars are converted into their corresponding ASCII code
				result = Integer.toString((int) ((Char) value).charValue());
			}
			else if (type.isEquivalent("Bool")) {
				result = (Boolean) value.toString();
			}
			// strings need a special treatment to become usable, 
			// so they actually define some code
			else if (type.isEquivalent("String")) {
				String reg = getCounterSSA().toString(); updateCounterSSA();
				code.add(LLVM.createAlloca(reg, type, (String) value.length()+1));
				code.add(LLVM.createStoreConstant(reg, type, value));
				String result = getCounterSSA().toString(); updateCounterSSA();
				code.add(LLVM.createArrayToPtrConversion(result, type, reg, ((String) value).length() + 1));
			}
			return result;
		}
	}	
	
	public static class ExprListAST extends BasicExprAST{
		ArrayList<ExprAST> exprArray;
		
		ExprListAST (ArrayList<ExprAST> exprArray, Type type) {
			this.exprArray = exprArray;
			this.type = type;
		}
		
		@Override
		String codegen() { 
			LinkedList<String> subExpResults = new LinkedList<>();
			String subExpResult;
			for (ExprAST expr: exprArray) {
				subExpResult = expr.codegen();
				subExpResults.add(subExpResult);
				mountCode(expr);
			}
			String reg = getCounterSSA().toString(); updateCounterSSA();
			code.add(LLVM.createAlloca(reg, type, exprArray.size()));
			int i = 0;
			for (String subExp: subExpResults) {
				code.addAll(LLVM.createStoreArrayElement(reg, type, subExp, i)); 
			}
			String result = getCounterSSA().toString(); updateCounterSSA();
			code.add(LLVM.createArrayToPtrConversion(result, type, reg, exprArray.size()));
			return result;
		}
	}
	
	public static class LFormArgAST extends BasicNodeAST{
		Type propType; // used for propagating type over the arguments
		ArrayList<String> argNames; // must be unique ids
		ArrayList<Type> argTypes;
		
		LFormArgAST (ArrayList<String> argNames, ArrayList<Type> argTypes, Type propType) {
			ArrayList<String> uniqueArgNames = argNames;
			uniqueArgNames.iterator().forEachRemaining( id -> { SymTableStack.createUniqueId(id); } );
			this.argNames = uniqueArgNames;
			this.argTypes = argTypes;
			this.propType = propType;
		}
		
		@Override
		String codegen() { return null; } //Formal Argument Code is generated when generating code for Function Definition
	}	
	
	public static class LLVM {
		private static int counterIf = 0;
		private static int counterSSA = 0;
		
		public static int getCounterIf() { return counterIf; }
		public static void updateCounterIf() { counterIf++; }
		public static void resetCounterSSA() { counterSSA = 0; }
		public static int getCounterSSA() { return counterSSA; }
		public static void updateCounterSSA() { counterSSA++; }
		
		public static String createPrintDeclaration() { return null; } //TODO
		public static LinkedList<String> createPrintFormatStrings() { return null; } //TODO
		public static String createMainDefinition() { return null; } //TODO
		public static LinkedList<String> openFunction() { return null; } //TODO
		public static String closeFunction() { return null; } //TODO
		public static String createReturnVoid() { return null; } //TODO
		// TODO ADD ALL METHODS
	
	}
	
:};

/*  In the Initialization Section, the typeMap (i.e. the list containing all declared types) is filled 
 *  with all the main Basic and Compound Types. 
 *  The only exception are Tuples, whose Type corresponds to the combination of the types of its elements;
 *  since such a Type would need too much space inside the typeMap, it is the ONLY Type that is not saved in the typeMap;
 *  so, it must be handled with specific procedures
 *  The "Any" Type acts as a wildcard and represents any possible Type (it represents Type Parameters)
 *  
 *  TODO Aggiungere metodi head, tail, size (per Liste), extract (per Tuple) nella symTable globale
 */
init with {:
		
		// Create the Table containing all Types and their Types
		CUP$Parser$actions.Type.createTypeMap();
		
		//CUP$Parser$actions.Type.dumpTypeMap();
		//CUP$Parser$actions.Type.testType();
		//CUP$Parser$actions.SymTableStack.testSymTableStack();
:}

/* Because of a bug in JavaCupMainDrawTree, the "scan with" directive does not substitute the default call to next_token as expected.
 * Instead, the user code is just inserted before the aforementioned call, preventing the user from customizing 
 * the scanning method (an "Unreachable statement" compiler error arises). 
 * For this reason, it is necessary to manually force the user code execution
 * This is the reason behind the fake conditional statement below
 */
scan with {:   
	if (true) {
		Scanner scanner = (Scanner) this.getScanner();
		Symbol s = scanner.next_token_custom();
		if (s.left != -1) {
			currLine = nextLine;		// keep track of current line and column
			currColumn = nextColumn;
			nextLine = s.left;
			nextColumn = s.right;
		}
		// build the graphical representation of the Parsing Tree
		Tree.push(s.toString(), 0);
		return s;
	}	
:}

/// ///////////////////////// ///
///	  TERMINALS (lowercase)   ///
/// ///////////////////////// ///

terminal main;
terminal eq, clns, cm, ro, rc, bo, bc, arrow, sep/*, us */;
terminal plus, minus, times, div, intdiv, mod, uminus, and, or, not;
//terminal head, tail, cons, conc; 
terminal length, index;
terminal releq, relnoteq, relge, relgt, relle, rellt;
terminal indent, dedent;
//terminal where, pipe;
terminal do_begin, if_begin, then, else_begin, let, in, print;
terminal Integer val_int;
terminal Double val_double;
terminal Boolean val_bool;
terminal Character val_char;
terminal String val_string;
terminal type_int, type_double, type_bool, type_string, type_char;
terminal String id;

/// ///////////////////////// ///
///	NON TERMINALS (uppercase) ///
/// ///////////////////////// ///

non terminal ProgramAST PROGRAM;
non terminal FunctPartAST FUNCT_PART;
non terminal ImperPartAST IMPER_PART;
non terminal LinkedList<DoStmtAST> IO_ACTIONS;
non terminal IOActionAST IO_ACTION;
non terminal PrintAST PRINT;
non terminal ExprAST COND, EXPR;
non terminal ExprListAST EXPR_LIST, LEXPR;
non terminal FunctCallAST FUNCT_CALL;
//non terminal ExprAST EXPR_NOTUNARYOP;
non terminal ExprAST ACTARG;
non terminal LinkedList<ExprAST> LACTARG;
non terminal LFormArgAST LFORMARG;
//non terminal WHERE, WHERE_STMTS, GUARDS, GUARD;
non terminal LinkedList<StmtAST> LET_STMTS, GLOBAL_STMTS;
non terminal DoBlockAST DO_BLOCK;
non terminal LetBlockFuncAST LET_BLOCK_FUNC;
non terminal LetBlockImperAST LET_BLOCK_IMPER;
non terminal IfBlockFuncAST IF_BLOCK_FUNC;
non terminal IfBlockImperAST IF_BLOCK_IMPER;
non terminal StmtAST STMT;
non terminal StmtAST DEF_VALUE;
non terminal DefFunctAST DEF_FUNCT;
non terminal DeclTypeAST DECL_TYPE;
non terminal Type TYPE, TYPE_VALUE, TYPE_FUNC, TYPE_LIST, TYPE_BASIC;
//non terminal LinkedList<Type> TTYPE_VALUE;
non terminal ValueAST VALUE, VALUE_BASIC;
//non terminal PATTERN, LPATTERN_CM, LPATTERN_CONS;
//non terminal PATTERN_LIST, PATTERN_TUPLE;

/// ///////////////////////// ///
///    PRECEDENCE RULES		  ///
/// ///////////////////////// ///

//precedence left conc;
//precedence right cons;
precedence left or;
precedence left and;
precedence nonassoc releq, relnoteq, relgt, relge, rellt, relle;
precedence left plus, minus;
precedence left times, div, intdiv, mod;
precedence nonassoc index;
precedence nonassoc not, uminus;

start with PROGRAM;

/// ///////////////////////// ///
///	   PRODUCTION RULES       ///
/// ///////////////////////// ///
 
PROGRAM ::= /* empty program */ 
			{:
				if (noCompileErrors) {
				System.out.println("CODE COMPILED SUCCESSFULLY");
				}
				RESULT = new ProgramAST(null, null);
			:}
		  | indent
			{:	// push the top-level symtable
				SymTableStack.pushSymTable();
				if (debug_mode) System.out.println("DEBUG: Top-level Symtable pushed");
			:}
			FUNCT_PART:funct_part IMPER_PART:imper_part 
			{:
				SymTableStack.popSymTable();
				if (debug_mode) System.out.println("DEBUG: Top-level Symtable popped");
			:}
			dedent 
			{:  // pop the top-level symtable
				if (noCompileErrors) {
					System.out.println("CODE COMPILED SUCCESSFULLY");
					RESULT = new ProgramAST(funct_part, imper_part);
					RESULT.codegen();
					// TODO COPY CODE TO OUTPUT FILE
				}	
				else {
					System.out.println("CODE NOT COMPILED: FAILED");
					RESULT = new ProgramAST(null, null);
				}
			:}
;

/// ////////////////// ///
///  IMPERATIVE PART   ///
/// ////////////////// ///

IMPER_PART ::= 
			main eq IO_ACTION:io_action
			{:
				RESULT = new ImperPartAST(io_action);
			:}			
		  | main eq error
			{: 
				report_syntax_error("Error in Main"); 
				RESULT = new ImperPartAST(null);
			:}
;

IO_ACTION ::= PRINT:print
			{: 
				RESULT = print; 
			:}
            | DO_BLOCK:do_block
			{: 
				RESULT = do_block; 
			:}
			| IF_BLOCK_IMPER:if_block_imper
			{: 
				RESULT = if_block_imper; 
			:}
;

IO_ACTIONS ::= 
		  IO_ACTIONS:io_actions sep IO_ACTION:io_action
		{:
			io_actions.add(io_action);
			RESULT = io_actions;
		:}
		| IO_ACTIONS:io_actions sep LET_BLOCK_IMPER:let_block_imper
		{:
			io_actions.add(let_block_imper);
			RESULT = io_actions;
		:}
		| IO_ACTION:io_action
		{: 
			LinkedList<DoStmtAST> ioActions = new LinkedList<>();
			ioActions.add(io_action);
			RESULT = ioActions;
		:}
		| LET_BLOCK_IMPER:let_block_imper
		{:
			LinkedList<DoStmtAST> ioActions = new LinkedList<>();
			ioActions.add(let_block_imper);
			RESULT = ioActions;
		:}
		| IO_ACTIONS:io_actions sep error
		{: 
			report_syntax_error("Error in Imperative Part Statement"); 
			RESULT = io_actions;
		:}
;

PRINT ::= print ACTARG:actarg
	{:
		Type argType = actarg.type;
		if (argType.isSubtype("Double") || argType.isSubtype("String") || argType.isSubtype("Bool")) {
			RESULT = new PrintAST(actarg);
		}
		else {
			report_semantic_error("Print does not support the Argument Type");
			RESULT = new PrintAST(null);
		}
	:}
;

DO_BLOCK ::=
		do_begin indent 
		{:
			SymTableStack.pushSymTable();
			if (debug_mode) System.out.println("DEBUG: Do Block - Symtable pushed");
		:}
		IO_ACTIONS:io_actions dedent
		{:
			SymTableStack.popSymTable();
			if (debug_mode) System.out.println("DEBUG: Do Block - Symtable popped");			
			RESULT = new DoBlockAST(io_actions);
		:}
	  | do_begin indent error dedent 
		{: 
			report_syntax_error("Error in Do Block"); 
			RESULT = new DoBlockAST(null);
		:}
;

IF_BLOCK_IMPER ::= 
		if_begin COND:cond then IO_ACTION:io_action_then else_begin IO_ACTION:io_action_else
		{:
			RESULT = new IfBlockImperAST(cond, io_action_then, io_action_else);
		:}
	  | if_begin error then IO_ACTION:io_action_then else_begin IO_ACTION:io_action_else 
		{: 
			report_syntax_error("Error in Condition of If Statement"); 
			RESULT = new IfBlockImperAST(null, io_action_then, io_action_else);
		:}
	  | if_begin COND:cond then error else_begin IO_ACTION:io_action_else 
		{: 
			report_syntax_error("Error in Then Block of If Statement"); 
			RESULT = new IfBlockImperAST(cond, null, io_action_else);
		:}
	  | if_begin COND:cond error else_begin IO_ACTION:io_action_else 
		{: 
			report_syntax_error("Missing \"Then\" in If Statement"); 
			RESULT = new IfBlockImperAST(cond, null, io_action_else);
		:}
;

LET_BLOCK_IMPER ::= 
		let indent LET_STMTS:let_stmts dedent// IO_ACTION:io_action 
		{:
			RESULT = new LetBlockImperAST(let_stmts); //, io_action);
		:}
	  /*| let error dedent // IO_ACTION:io_action
		{: 
			report_syntax_error("Error in Let Statements of a Let Block"); 
			RESULT = new LetBlockImperAST(null); //, io_action);
		:}*/
;
// DEF_FUNCT not supported (for now)
LET_STMTS ::= LET_STMTS:let_stmts sep DECL_TYPE:decl_type
			{:
				if(decl_type.type.isSubtype("Function")) {
					report_semantic_error("No Support for Local Functions");
				}
				RESULT = let_stmts;
				RESULT.add(decl_type);
			:}
			| LET_STMTS:let_stmts sep DEF_VALUE:def_value
			{:
				RESULT = let_stmts;
				RESULT.add(def_value);
			:}
			| DECL_TYPE:decl_type
			{:
				if(decl_type.type.isSubtype("Function")) {
					report_semantic_error("No Support for Local Functions");
				}
				RESULT = new LinkedList<StmtAST>();
				RESULT.add(decl_type);
			:}
			| DEF_VALUE:def_value
			{:
				RESULT = new LinkedList<StmtAST>();
				RESULT.add(def_value);
			
			:}
;

/// ////////////////// ///
///  FUNCTIONAL PART   ///
/// ////////////////// ///
 
FUNCT_PART ::= GLOBAL_STMTS:global_stmts
			{:
				RESULT = new FunctPartAST(global_stmts);
			:}
; 
 
GLOBAL_STMTS ::= /* empty List of Statements section */
			{:
				RESULT = new LinkedList<StmtAST>();
			:}
			 | GLOBAL_STMTS:global_stmts STMT:stmt sep
			{:
				global_stmts.add(stmt);
				RESULT = global_stmts;
			:}
			 | GLOBAL_STMTS:global_stmts error sep 
			{: 
				report_syntax_error("Error in Functional Statement"); 
				global_stmts.add(null);
				RESULT = global_stmts;
			:}
;

///  STATEMENTS  ///

STMT ::= DECL_TYPE:decl_type
		{: // Global Lists and Functions returning Lists are not supported in this version of the compiler 
			if (decl_type.type.isSubtype("List")) {
				report_semantic_error("Global Lists not supported");
			}
			RESULT = decl_type;
		:}
	   | DEF_VALUE:def_value
	   {:
			RESULT = def_value;
	   :}
	   | DEF_FUNCT:def_funct
	   {:
			RESULT = def_funct;
	   :}
;

DECL_TYPE ::= id:id cm DECL_TYPE:decl_type
			{:
				Type type = decl_type.type;
				if (!isLocallyDeclared(id) && !(type.isSubtype("Function") && returnType(type).isSubtype("List"))) {
					SymTableStack.putEntry(id, new SymTableStack.SymTableEntry(type));
				}
				else if (isLocallyDeclared(id)) {
					report_semantic_error("Multiple Value Declaration (Symbol \"" + id + "\")");
				}
				else {
					report_semantic_error("Lists as a Return Value are not supported");
				}
				RESULT = new DeclTypeAST(new Type(type));
			:}
			| id:id clns TYPE:type
			{:
				if (!isLocallyDeclared(id) && !(type.isSubtype("Function") && returnType(type).isSubtype("List"))) {
					SymTableStack.putEntry(id, new SymTableStack.SymTableEntry(type));
				}
				else if (isLocallyDeclared(id)) {
					report_semantic_error("Multiple Value Declaration (Symbol \"" + id + "\")");
				}
				else {
					report_semantic_error("Lists as a Return Value are not supported");
				}
				RESULT = new DeclTypeAST(type);
			:}
; 

/* pattern and expr should be of the same type */
//DEF_VALUE ::= PATTERN eq EXPR
DEF_VALUE ::= id:id 
			{:
				if (isDeclared(id) && isLocallyDeclared(id) && !isAssigned(id)) {
					SymTableStack.getEntry(id).setIsAssigned(true);
				}
				else {
					if (!isDeclared(id)) {
						report_semantic_error("Missing Value Declaration (Symbol \"" + id + "\")");
					}
					else if (!isLocallyDeclared(id)) {
						report_semantic_error("Value is not Locally Declared (Symbol \"" + id + "\")");
					}
					else if (isAssigned(id)) {
						report_semantic_error("Multiple Value Assignment (Symbol \"" + id + "\")");
					}
				}
			:}
			eq EXPR:expr
			{:
				if (isDeclared(id) && isLocallyDeclared(id) && isAssigned(id) && !expr.type.isEquivalent(SymTableStack.getEntry(id).getType().getTypeName())) {
						report_semantic_error("Mismatching Type on Assignment (Symbol \"" + id + "\")"); 
				}
				if (isGlobal(id)) {
					// Global Values are actually Nullary Functions
					ArrayList<String> argNames = new ArrayList<>();
					ArrayList<Type> argTypes = new ArrayList<>();
					LFormArgAST lformarg = new LFormArgAST(argNames, argTypes, expr.type);
					RESULT = new DefFunctAST(id, lformarg, expr);
				}
				else {
					RESULT = new DefValueAST(id, expr);
				}
			:}
;
/* no nullary functions */
DEF_FUNCT ::= id:id {: 
					if (isDeclared(id) && isLocallyDeclared(id) && !isAssigned(id)) {
						SymTableStack.getEntry(id).setIsAssigned(true);	
					}
					else if (!isDeclared(id)) {
						report_semantic_error("Missing Function Declaration (Symbol \"" + id + "\")");
					}
					else if (!isLocallyDeclared(id)) {
						report_semantic_error("Function is not Locally Declared (Symbol \"" + id + "\")");
					}
					else if (isAssigned(id)) {
						report_semantic_error("Multiple Function Assignment (Symbol \"" + id + "\")");
					}
					SymTableStack.pushSymTable();
					if (debug_mode) System.out.println("DEBUG: Function Declaration - Symtable pushed");
			   :}
			   LFORMARG:lformarg eq 
			   EXPR:expr {:
					Type idTree = null;
					if (isDeclared(id)){
						idTree = SymTableStack.getEntry(id).getType();
						if (idTree != null && !idTree.isSubtype("Function")) {
							report_semantic_error("Not a Function (Symbol \"" + id + "\")");
						}
						else if (!hasArity(id, lformarg.argNames.size())) {
							report_semantic_error("Mismatching Arity (Symbol \"" + id + "\")");
						}
						else if (!expr.type.isEquivalent(returnType(id).getTypeName())) {
							report_semantic_error("Return Type is not equivalent to the Expression Type (Symbol \"" + id + "\")");
						}
					}
					SymTableStack.popSymTable();
					if (debug_mode) System.out.println("DEBUG: Function Declaration - Symtable popped");
					RESULT = new DefFunctAST(id, lformarg, expr);
			   :}  
;

/* GUARDS ::= GUARDS sep GUARD
         | GUARD
;

   GUARD ::= pipe COND eq EXPR
; */

/* WHERE ::= // no where section 
        | where indent WHERE_STMTS dedent
; 

   WHERE_STMTS ::= WHERE_STMTS sep DECL 
			  | DECL
;*/

///  PATTERN MATCHING   ///

/*LFORMARG ::= LFORMARG PATTERN
		   | PATTERN
;

PATTERN ::= PATTERN_LIST
		  | PATTERN_TUPLE
		  | VALUE_BASIC
		  | us
		  | id
;

PATTERN_LIST ::= ro PATTERN cons LPATTERN_CONS rc // value constructor pattern
			   | bo LPATTERN_CM bc	// value pattern
			   | bo bc
;

LPATTERN_CONS ::= PATTERN
				| PATTERN cons LPATTERN_CONS
;

PATTERN_TUPLE ::= ro PATTERN cm LPATTERN_CM rc
				| ro rc
;

LPATTERN_CM ::= PATTERN
			  | PATTERN cm LPATTERN_CM
; */

LFORMARG ::= LFORMARG:lformarg id:id 
			{:
				Type propTree = lformarg.propType;
				if (!isLocallyDeclared(id) && propTree != null && propTree.isSubtype("Function")) {
					Type argTree = new Type(propTree.getTypeParam(0));
					SymTableStack.putEntry(id, new SymTableStack.SymTableEntry(argTree, true));
					lformarg.argNames.add(id);
					lformarg.argTypes.add(argTree);
					RESULT = new LFormArgAST(lformarg.argNames, lformarg.argTypes, propTree.getTypeParam(1));
				}
				else if (isLocallyDeclared(id)) {
					report_semantic_error("Multiple Argument Declaration (Symbol \"" + id + "\")");
					// Error Recovery
					lformarg.argNames.add(id);
					lformarg.argTypes.add(Type.getType("error"));
					RESULT = new LFormArgAST(lformarg.argNames, lformarg.argTypes, propTree.getTypeParam(1));
				}
				else {
					report_semantic_error("Mismatching Arity in Function"); 
					// Error Recovery
					lformarg.argNames.add(id);
					lformarg.argTypes.add(Type.getType("error"));
					RESULT = new LFormArgAST(lformarg.argNames, lformarg.argTypes, Type.getType("error"));
				}
			:}
		   | id:id 
		   {:
				String funcName = (String) parser.stack(-2);
				if (isDeclared(funcName)) {
					Type type = SymTableStack.getEntry(funcName).getType();
					if (!isLocallyDeclared(id) && type != null && type.isSubtype("Function")) {
						Type argTree = new Type(type.getTypeParam(0));
						SymTableStack.putEntry(id, new SymTableStack.SymTableEntry(argTree, true));
						ArrayList<String> argNames = new ArrayList<>();
						ArrayList<Type> argTypes = new ArrayList<>();
						argNames.add(id);
						argTypes.add(argTree);
						RESULT = new LFormArgAST(argNames, argTypes, type.getTypeParam(1));
					}
					else if (isLocallyDeclared(id)) {
						report_semantic_error("Multiple Argument Declaration (Symbol \"" + id + "\")");
						// Error Recovery
						ArrayList<String> argNames = new ArrayList<>();
						ArrayList<Type> argTypes = new ArrayList<>();
						argNames.add(id);
						argTypes.add(Type.getType("error"));
						RESULT = new LFormArgAST(argNames, argTypes, type.getTypeParam(1));
					}
					else {
						report_semantic_error("Mismatching Arity in Function"); 
						// Error Recovery
						ArrayList<String> argNames = new ArrayList<>();
						ArrayList<Type> argTypes = new ArrayList<>();
						argNames.add(id);
						argTypes.add(Type.getType("error"));
						RESULT = new LFormArgAST(argNames, argTypes, Type.getType("error"));
					}
				}
				else {
					report_semantic_error("Missing Function Declaration (Symbol \"" + funcName + "\")");
					ArrayList<String> argNames = new ArrayList<>();
					ArrayList<Type> argTypes = new ArrayList<>();
					argNames.add(id);
					argTypes.add(Type.getType("error"));
					RESULT = new LFormArgAST(argNames, argTypes, Type.getType("error"));
				}
				
		   :}
;

/* special expression management for boolean conditions */
COND ::= EXPR:expr {:
					if (!expr.type.isEquivalent("Bool")) {
						report_semantic_error("Wrong Type in Condition (Expected Type: Bool)");
					}
					RESULT = expr;
			   :}
;

///   EXPRESSIONS   ///

//EXPR ::= //EXPR:expr1 plus EXPR_NOTUNARYOP:expr2
EXPR ::= EXPR:expr1 plus EXPR:expr2
		{:
			String opType = "+";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if (expr1.type.isSubtype("Double") && expr2.type.isSubtype("Double") && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(new Type(expr1.type), ExprKind.PLUS, subExpressions);
			}
			else if (!expr1.type.isSubtype("Double")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.PLUS, subExpressions);
			}
			else if (!expr2.type.isSubtype("Double")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.PLUS, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.PLUS, subExpressions);
			}
		:}
	   //| EXPR:expr1 minus EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 minus EXPR:expr2
	   {:
			String opType = "-";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if (expr1.type.isSubtype("Double") && expr2.type.isSubtype("Double") && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(new Type(expr1.type), ExprKind.MINUS, subExpressions);
			}
			else if (!expr1.type.isSubtype("Double")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.MINUS, subExpressions);
			}
			else if (!expr2.type.isSubtype("Double")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");	
				RESULT = new ExprAST(Type.getType("error"), ExprKind.MINUS, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.MINUS, subExpressions);
			}
		:}
	   //| EXPR:expr1 times EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 times EXPR:expr2
	   {:
			String opType = "*";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if (expr1.type.isSubtype("Double") && expr2.type.isSubtype("Double") && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(new Type(expr1.type), ExprKind.TIMES, subExpressions);		
			}
			else if (!expr1.type.isSubtype("Double")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.TIMES, subExpressions);
			}
			else if (!expr2.type.isSubtype("Double")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.TIMES, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.TIMES, subExpressions);
			}
		:}
	   //| EXPR:expr1 div EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 div EXPR:expr2
	   {:
			String opType = "/";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if (expr1.type.isSubtype("Double") && expr2.type.isSubtype("Double") && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Double"), ExprKind.DIV, subExpressions);
			}
			else if (!expr1.type.isSubtype("Double")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.DIV, subExpressions); 
			}
			else if (!expr2.type.isSubtype("Double")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.DIV, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.DIV, subExpressions);
			}
		:}
	   //| EXPR:expr1 intdiv EXPR_NOTUNARYOP:expr2 
	   | EXPR:expr1 intdiv EXPR:expr2 
	   {:
			String opType = "div";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if (expr1.type.isSubtype("Int") && expr2.type.isSubtype("Int") && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Int"), ExprKind.INTDIV, subExpressions);
			}
			else if (!expr1.type.isSubtype("Int")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.INTDIV, subExpressions);
			}
			else if (!expr2.type.isSubtype("Int")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.INTDIV, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.INTDIV, subExpressions);
			}
		:}
	   | EXPR:expr1 mod EXPR:expr2 
	   {:
			String opType = "mod";	
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if (expr1.type.isSubtype("Int") && expr2.type.isSubtype("Int") && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Int"), ExprKind.MOD, subExpressions);
			}
			else if (!expr1.type.isSubtype("Int")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.MOD, subExpressions);
			}
			else if (!expr2.type.isSubtype("Int")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.MOD, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.MOD, subExpressions);
			}
		:}
	   //| EXPR:expr1 and EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 and EXPR:expr2
	   {:
			String opType = "&&";		
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if (expr1.type.isSubtype("Bool") && expr2.type.isSubtype("Bool") && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Bool"), ExprKind.AND, subExpressions);
			}
			else if (!expr1.type.isSubtype("Bool")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.AND, subExpressions);
			}
			else if (!expr2.type.isSubtype("Bool")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.AND, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.AND, subExpressions);
			}
	   :}
	   //| EXPR:expr1 or EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 or EXPR:expr2
	    {:
			String opType = "||";		
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if (expr1.type.isSubtype("Bool") && expr2.type.isSubtype("Bool") && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Bool"), ExprKind.OR, subExpressions);
			}
			else if (!expr1.type.isSubtype("Bool")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.OR, subExpressions);
			}
			else if (!expr2.type.isSubtype("Bool")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.OR, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.OR, subExpressions);
			}
	   :}
	   | EXPR:expr1 relnoteq EXPR:expr2
	    {:
			String opType = "/=";		
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if ((expr1.type.isSubtype("Char") || expr1.type.isSubtype("Double")) && (expr2.type.isSubtype("Char") || expr2.type.isSubtype("Double")) && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Bool"), ExprKind.RELNOTEQ, subExpressions);
			}
			else if (!expr1.type.isSubtype("Double") && !expr1.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELNOTEQ, subExpressions);
			}
			else if (!expr2.type.isSubtype("Double") && !expr2.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELNOTEQ, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELNOTEQ, subExpressions);
			}
		:}
	   //| EXPR:expr1 releq EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 releq EXPR:expr2
	    {:
			String opType = "==";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if ((expr1.type.isSubtype("Char") || expr1.type.isSubtype("Double")) && (expr2.type.isSubtype("Char") || expr2.type.isSubtype("Double")) && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Bool"), ExprKind.RELEQ, subExpressions);
			}
			else if (!expr1.type.isSubtype("Double") && !expr1.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELEQ, subExpressions);
			}
			else if (!expr2.type.isSubtype("Double") && !expr2.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELEQ, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELEQ, subExpressions);
			}
		:}
	   //| EXPR:expr1 relgt EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 relgt EXPR:expr2
	   {:
			String opType = ">";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if ((expr1.type.isSubtype("Char") || expr1.type.isSubtype("Double")) && (expr2.type.isSubtype("Char") || expr2.type.isSubtype("Double")) && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Bool"), ExprKind.RELGT, subExpressions);
			}
			else if (!expr1.type.isSubtype("Double") && !expr1.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELGT, subExpressions); 
			}
			else if (!expr2.type.isSubtype("Double") && !expr2.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELGT, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELGT, subExpressions);
			}
		:}
	   //| EXPR:expr1 relge EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 relge EXPR:expr2
	   {:
	   		String opType = ">=";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if ((expr1.type.isSubtype("Char") || expr1.type.isSubtype("Double")) && (expr2.type.isSubtype("Char") || expr2.type.isSubtype("Double")) && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Bool"), ExprKind.RELGE, subExpressions);
			}
			else if (!expr1.type.isSubtype("Double") && !expr1.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELGE, subExpressions);
			}
			else if (!expr2.type.isSubtype("Double") && !expr2.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELGE, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELGE, subExpressions);
			}
		:}
	   //| EXPR:expr1 rellt EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 rellt EXPR:expr2
	   {:
			String opType = "<";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if ((expr1.type.isSubtype("Char") || expr1.type.isSubtype("Double")) && (expr2.type.isSubtype("Char") || expr2.type.isSubtype("Double")) && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Bool"), ExprKind.RELLT, subExpressions);
			}
			else if (!expr1.type.isSubtype("Double") && !expr1.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELLT, subExpressions);
			}
			else if (!expr2.type.isSubtype("Double") && !expr2.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELLT, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELLT, subExpressions);
			}
		:}
	   //| EXPR:expr1 relle EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 relle EXPR:expr2
	   {:
			String opType = "<=";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if ((expr1.type.isSubtype("Char") || expr1.type.isSubtype("Double")) && (expr2.type.isSubtype("Char") || expr2.type.isSubtype("Double")) && expr1.type.isEquivalent(expr2.type.getTypeName())) {
				RESULT = new ExprAST(Type.getType("Bool"), ExprKind.RELLE, subExpressions);
			}
			else if (!expr1.type.isSubtype("Double") && !expr1.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELLE, subExpressions);
			}
			else if (!expr2.type.isSubtype("Double") && !expr2.type.isSubtype("Char")) {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELLE, subExpressions);
			}
			else {
				report_semantic_error("Mismatching Operand Type on \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.RELLE, subExpressions);
			}
		:}
	   //| head ACTARG
	   //| tail ACTARG
	   | length ACTARG:actarg
	   {:
			String opType = "length";
			BasicExprAST[] subExpressions = { actarg };
			if (actarg.type.isSubtype("List")) {
				RESULT = new ExprAST(Type.getType("Int"), ExprKind.LENGTH, subExpressions);
			}
			else {
				report_semantic_error("Wrong Type in \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.LENGTH, subExpressions);
			}
	   :}
	   //| EXPR:expr1 index EXPR_NOTUNARYOP:expr2
	   | EXPR:expr1 index EXPR:expr2
	   {:
			String opType = "!!";
			BasicExprAST[] subExpressions = { expr1, expr2 };
			if (expr1.type.isSubtype("List") && expr2.type.isSubtype("Int")) {
				RESULT = new ExprAST(new Type(expr1.type.getTypeParam(0)), ExprKind.INDEX, subExpressions);
			}
			else if (!expr1.type.isSubtype("List")){
				report_semantic_error("Wrong Type in LHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.INDEX, subExpressions); 
			}
			else {
				report_semantic_error("Wrong Type in RHS of \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.INDEX, subExpressions); 
			}
	   :}
	   //| EXPR cons EXPR_NOTUNARYOP
	   //| EXPR conc EXPR_NOTUNARYOP
	   | ro EXPR:expr rc
	   {:
			RESULT = expr;
	   :}
	   //| ro not EXPR:expr rc
	   | not EXPR:expr  
	   {:
			String opType = "not";
			BasicExprAST[] subExpressions = { expr };
			if(expr.type.isSubtype("Bool")) {
				RESULT = new ExprAST(Type.getType("Bool"), ExprKind.NOT, subExpressions);
			}
			else {
				report_semantic_error("Wrong Type in \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.NOT, subExpressions); 
			}
	   :}
	   | minus EXPR:expr
		//| ro minus EXPR:expr rc 
	   {:
			String opType = "Unary \"-\"";
			BasicExprAST[] subExpressions = { expr };
			if(expr.type.isSubtype("Double")){
				RESULT = new ExprAST(new Type(expr.type), ExprKind.UMINUS, subExpressions);
			}
			else {
				report_semantic_error("Wrong Type in \"" + opType + "\" Expression");
				RESULT = new ExprAST(Type.getType("error"), ExprKind.UMINUS, subExpressions); 
			}
	   :} %prec uminus 
	   | LET_BLOCK_FUNC:let_block_func 
	   {:
			BasicExprAST[] subExpressions = { let_block_func };
			RESULT = new ExprAST(let_block_func.type, ExprKind.LET_BLOCK_FUNC, subExpressions);
	   :}
	   | IF_BLOCK_FUNC:if_block_func 
	   {:
			BasicExprAST[] subExpressions = { if_block_func };
			RESULT = new ExprAST(if_block_func.type, ExprKind.IF_BLOCK_FUNC, subExpressions);
	   :}
	   | FUNCT_CALL:funct_call
	   {:
			BasicExprAST[] subExpressions = { funct_call };
			RESULT = new ExprAST(funct_call.type, ExprKind.FUNCT_CALL, subExpressions);
	   :}
	   | VALUE:value
	   {:
			BasicExprAST[] subExpressions = { value };
			RESULT = new ExprAST(value.type, ExprKind.VALUE, subExpressions);
	   :}
	   | EXPR_LIST:expr_list
	   {:
			BasicExprAST[] subExpressions = { expr_list };
			RESULT = new ExprAST(expr_list.type, ExprKind.EXPR_LIST, subExpressions);
	   :}
;

FUNCT_CALL ::= id:id LACTARG:lactarg 
	   {:
			int nArgs = lactarg.size();
			Type funcType = null;
			boolean failedArgsTypeChecking = false;
			if(isDeclared(id) && isAssigned(id)) {
				funcType = SymTableStack.getEntry(id).getType();
				//funcType.dumpType(0);
				// This is a Value Call
				if (nArgs == 0) {
					if (funcType != null && !funcType.isSubtype("Function")) { // This is not a Function Call, but a reference to a Value
						//RESULT = new ExprAST(new Type(funcType));
						RESULT = new FunctCallAST(new Type(funcType), id, lactarg); 
					}
					else {
						// Error Recovery
						report_semantic_error("Not a Value (Symbol \"" + id + "\")");
						//RESULT = new ExprAST(Type.getType("error"));  
						RESULT = new FunctCallAST(Type.getType("error"), id, lactarg);
					}
				}
				// This is a Function Call
				else if (nArgs > 0) {
					if (funcType != null && funcType.isSubtype("Function") && hasArity(id, nArgs)) {
						for (ExprAST actarg : lactarg) {
							if (!actarg.type.isEquivalent(funcType.getTypeParam(0)))
								failedArgsTypeChecking = true;
							funcType = funcType.getTypeParam(1); //extract the right child of the funcType Tree
						}
						if (!failedArgsTypeChecking) {
							//RESULT = new ExprAST(new Type(funcType));
							RESULT = new FunctCallAST(new Type(funcType), id, lactarg);
						}	
						else {
							// Error Recovery
							report_semantic_error("Wrong Type in Arguments applied to Function " + id);
							//RESULT = new ExprAST(Type.getType("error")); 
							RESULT = new FunctCallAST(Type.getType("error"), id, lactarg);
						}
					}
					else if (funcType == null || !funcType.isSubtype("Function")) {
						// Error Recovery
						report_semantic_error("Not a Function (Symbol \"" + id + "\")");
						//RESULT = new ExprAST(Type.getType("error")); 
						RESULT = new FunctCallAST(Type.getType("error"), id, lactarg);
					}
					else if (!hasArity(id, nArgs)) {
						// Error Recovery
						report_semantic_error("Mismatching Arity (Symbol \"" + id + "\")");
						//RESULT = new ExprAST(Type.getType("error")); 
						RESULT = new FunctCallAST(Type.getType("error"), id, lactarg);
					}
				}
			}
			else if (!isDeclared(id)){
				// Error Recovery
				report_semantic_error("Missing Value Declaration (Symbol \"" + id + "\")");
				RESULT = new FunctCallAST(Type.getType("error"), id, lactarg);
			}
			else if (!isAssigned(id)) {
				// Error Recovery
				report_semantic_error("Value Declared but not Assigned (Symbol \"" + id + "\")");
				RESULT = new FunctCallAST(Type.getType("error"), id, lactarg);
			}
	   :}
;

LET_BLOCK_FUNC ::= 	let indent 
					{:
						SymTableStack.pushSymTable();
						if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable pushed");
					:} 
					LET_STMTS:let_stmts dedent in EXPR:expr {:
						SymTableStack.popSymTable();
						if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable popped");
						RESULT = new LetBlockFuncAST(new Type(expr.type), let_stmts, expr);
					:}
					| let error in EXPR:expr
					{: report_syntax_error("Error in Statement inside a Let Block"); 
						RESULT = new LetBlockFuncAST(Type.getType("error"), null, expr);
					:}
;


IF_BLOCK_FUNC ::= if_begin COND:cond then EXPR:thenBody else_begin EXPR:elseBody 
				{:
					if(thenBody.type.isEquivalent(elseBody.type)) {
						RESULT = new IfBlockFuncAST(thenBody.type, cond, thenBody, elseBody);
					}
					else {
						report_semantic_error("Multiple Return Types for If Statement");
						RESULT = new IfBlockFuncAST(Type.getType("error"), cond, thenBody, elseBody); 
					}
				:}
				| if_begin error else_begin EXPR:elseBody
				{:  
					report_syntax_error("Error in Condition inside an If-Then-Else Block");
					RESULT = new IfBlockFuncAST(Type.getType("error"), null, null, elseBody);
				:}
				| if_begin COND:cond then error else_begin EXPR:elseBody
				{:  
					report_syntax_error("Error in Then Block of an In-Then-Else Block"); 
					RESULT = new IfBlockFuncAST(Type.getType("error"), cond, null, elseBody);
				:}
				//| error then EXPR else_begin EXPR
				//	{: report_syntax_error("Missing 'if' inside an If-Then-Else Block"); 
				//		RESULT = new IfBlockFuncAST(Type.getType("error"));
				//	:}
				| if_begin COND:cond error else_begin EXPR:elseBody
				{: 
					report_syntax_error("Missing 'then' inside an If-Then-Else Block"); 
					RESULT = new IfBlockFuncAST(Type.getType("error"), cond, null, elseBody);
				:}
;

// DA QUI
///    args for function call   ///

ACTARG ::= id:id 
		{:
			Type idType;
			LinkedList<ExprAST> actArgs = new LinkedList<>();
			FunctCallAST functCall;
			BasicExprAST[] subExpressions = new BasicExprAST[1];
			if (isDeclared(id) && isAssigned(id)) {
				idType = SymTableStack.getEntry(id).getType();
				functCall = new FunctCallAST(idType, id, actArgs);
				subExpressions[0] = functCall;
				RESULT = new ExprAST(new Type(idType), ExprKind.FUNCT_CALL, subExpressions);
			} // DA QUI
			else if (!isDeclared(id)){
				report_semantic_error("Missing Value Declaration (Symbol \"" + id + "\")");
				idType = Type.getType("error");
				functCall = new FunctCallAST(idType, id, actArgs);
				subExpressions[0] = functCall;
				RESULT = new ExprAST(new Type(idType), ExprKind.FUNCT_CALL, subExpressions);
			}
			else {
				report_semantic_error("Value Declared but Not Assigned (Symbol \"" + id + "\")");
				idType = Type.getType("error");
				functCall = new FunctCallAST(idType, id, actArgs);
				subExpressions[0] = functCall;
				RESULT = new ExprAST(new Type(idType), ExprKind.FUNCT_CALL, subExpressions);
			}
		:}
         | VALUE:value
		{:
			BasicExprAST[] subExpressions = { value };
			RESULT = new ExprAST(value.type, ExprKind.VALUE, subExpressions);			
		:}
		 | ro EXPR:expr rc
		{:
			RESULT = expr;			
		:}
;

// list of input arguments for function call
LACTARG ::= /* empty list of args: we call a Value */
			{: 
				RESULT = new LinkedList<ExprAST>();
			:}
		  | LACTARG:lactarg ACTARG:actarg
			{:
				lactarg.add(actarg);
				RESULT = lactarg;
			:}
;

///   VALUES   ///

VALUE ::= VALUE_BASIC:value_basic
		{: 
			RESULT = value_basic;
		:}
		/*| EXPR_LIST:value_list
		{:
			RESULT = new ValueAST(value_list.type, value_list.value);
		:}*/
//		| VALUE_TUPLE
;

// VALUE_BASIC represents constants
VALUE_BASIC ::= 
		val_int:val_int
			{:
				RESULT = new ValueAST(Type.getType("Int"), val_int);
			:}
	  | val_double:val_double
			{:
				RESULT = new ValueAST(Type.getType("Double"), val_double);
			:}	  
	  | val_bool:val_bool
			{:
				RESULT = new ValueAST(Type.getType("Bool"), val_bool);
			:}
	  | val_char:val_char
			{:
				RESULT = new ValueAST(Type.getType("Char"), val_char);
			:}
	  | val_string:val_string
			{:
				RESULT = new ValueAST(Type.getType("String"), val_string);
			:}
;

// Empty List can only be directly used in declaration, to avoid Type Variables propagation
EXPR_LIST ::= bo LEXPR:lexpr bc
		{:
			RESULT = lexpr;
		:}
;

//VALUE_TUPLE ::= ro TEXPR rc
//;

LEXPR ::= EXPR:expr
		{:
			ArrayList<ExprAST> lexpr = new ArrayList<>();
			lexpr.add(expr);
			Type type = Type.getType("List");
			type.setTypeParam(0, expr.type);
			RESULT = new ExprListAST(lexpr, type);
		:}
		| LEXPR:lexpr cm EXPR:expr 
		{:
			if (!lexpr.type.getTypeParam(0).isEquivalent(expr.type)) {
				report_semantic_error("Wrong Type in List Expression");
			}
			RESULT = lexpr;
			RESULT.exprArray.add(expr);
		:}
		//| error cm EXPR
		//	{: report_syntax_error("Error in List of Expressions"); :}
;

//TEXPR ::= EXPR cm EXPR
//		| TEXPR cm EXPR
//;

///   TYPES   ///

TYPE ::= TYPE_VALUE:type_value {: RESULT = type_value; :}
	   | TYPE_FUNC:type_func {: RESULT = type_func; :}
;

// both basic types and compound
TYPE_VALUE ::= TYPE_LIST:type_list {: RESULT = type_list; :}
			 | TYPE_BASIC:type_basic {: RESULT = type_basic; :}
//			 | TYPE_TUPLE
;

TYPE_BASIC ::= type_int {: RESULT = Type.getType("Int"); :}
			 | type_double {: RESULT = Type.getType("Double"); :}
			 | type_bool {: RESULT = Type.getType("Bool"); :}
			 | type_char {: RESULT = Type.getType("Char"); :}
;

TYPE_LIST ::= bo TYPE_BASIC:type_basic bc 
		{: 
		   Type type = Type.getType("List");
		   type.setTypeParam(0, type_basic);
		   RESULT = type;
		:}
		| type_string {: RESULT = Type.getType("String"); :}
;

//TYPE_TUPLE ::= ro TTYPE_VALUE rc
//;

// no higher order functions
TYPE_FUNC ::= TYPE_VALUE:type_value arrow TYPE_FUNC:type_func
		{:
			Type type = Type.getType("Function");
			type.setTypeParam(0, type_value);
			type.setTypeParam(1, type_func);
			RESULT = type;
		:}
		    | TYPE_VALUE:type_valueL arrow TYPE_VALUE:type_valueR
		{:
			Type type = Type.getType("Function");
			type.setTypeParam(0, type_valueL);
			type.setTypeParam(1, type_valueR);
			RESULT = type;
		:}
			//| error arrow TYPE_VALUE
		//{: report_syntax_error("Error in Argument Type of Function"); :}
			//| error arrow TYPE_FUNC
		//{: report_syntax_error("Error in Argument Type of Function"); :}
;

// 0-Tuple are not allowed
//TTYPE_VALUE ::= TYPE_VALUE cm TYPE_VALUE
//			  | TTYPE_VALUE cm TYPE_VALUE
//;



