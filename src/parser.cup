import java_cup.runtime.*;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Stack;
import java.util.Iterator;

parser code {:

	private String outputFileName;

	public boolean noCompileErrors = true;
	
	/*
	 *  Define the name of the output file, containing the final Intermediate Representation in LLVM
	 *	Params: String outputFileName - name of the output file
	 *	Return: nothing
	 */
	public void setOutputFileName(String outputFileName) {
		this.outputFileName = outputFileName;
	}
	
	/* 
	 * 	Default Cup Function for reporting Syntax Errors
	 *  Params: java_cup.runtime.Symbol current - The last parsed symbol before raising the last Syntax Error 
	 *  Return: nothing
	 */
	public void syntax_error(java_cup.runtime.Symbol current) {
		report_error("", current);
	}
	
	/*
	 * Function to retrieve values directly from the Stack
	 * @param: int position - position wrt the top of the Stack
	 * @return: Object - the corresponding element of the Stack 
	 */
    public Object stack(int position) {
        return (((Symbol)stack.elementAt(tos+position)).value);
    }
	
	/* 
	 *  Inform the user that a Syntax Error has been raised, and inform them about the nature of the Syntax Error
	 *	Params: Object info - The last parsed symbol before raising the last Syntax Error
	 *  		String msg - The additional message describing the kind of Syntax Error
	 *	Return: nothing
	 */
    public void report_error(String msg, Object info) {
		noCompileErrors = false;
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left);
                int column = (((Symbol)info).right);
                System.err.print(" (line "+line+", column "+column+"): " + msg);
            } else System.err.print(": " + msg);
        else System.err.print(": " + msg);
    }
	
	public void report_semantic_error(String msg) {
		noCompileErrors = false;
		System.err.print("ERROR: Semantic error");
        //if (info instanceof Symbol)
        //    if (((Symbol)info).left != -1){
        //        int line = (((Symbol)info).left);
        //        int column = (((Symbol)info).right);
        //System.err.println(" (line "+line+", column "+column+"): " + msg);
        //    } else System.err.println(": " + msg);
        //else System.err.println(": " + msg);
		System.err.println(": " + msg);
	}
	
:};

action code {:

	/*
	 * Boolean flag that provides additional information for debugging purposes, when raised
	 */
	public static boolean debug_mode = true; 
	
	/* 
	 * Class for the Type Tree
	 * The following Class defines the TypeTree structure
	 * Fields: String typeName - unique name for the Type
	 * 		   TypeTree[] - list containing all the subtrees for an instance of a compound type 
	 *				(useful for functions, lists, tuples and any additional compound type) 
	 *		   Hashmap<String, TypeTree> typeMap - a map containg, for any typeName, the corresponding standard TypeTree
	 *				(initialized at Parser initialization time)
	 */
	public static class TypeTree {
		
		private String typeName;
		private TypeTree[] childs; //better than an ArrayList because its size it's fixed
		
		/* Basic Copy Constructor */
		TypeTree(String typeName, TypeTree[] childs) {
			this.typeName = typeName;
			this.childs = childs; // most types should have up to 2 type params
		}
		
		/* (Recursive) Copy Constructor */
		TypeTree(TypeTree tree) {			
			int length = tree.getChilds().length;
			this.typeName = tree.getTypeName();
			this.childs = new TypeTree[length];
			for (int i = 0; i < length; i++) {
				this.childs[i] = new TypeTree(tree.getChilds()[i]);
			}
		}
		
		/* Setter method for typeName */
		public void setTypeName(String typeName) {
			this.typeName = typeName;
		}
		
		
		/* Setter method for childs */
		public void setChilds(TypeTree[] childs){
			this.childs = childs;
		}
		
		/* Setter method for the single child */
		public void setChild(int pos, TypeTree child) {
			this.childs[pos] = child;
		}
		
		/* Getter method for typeName */
		public String getTypeName(){
			return this.typeName;
		}
		
		/* Getter method for childs */
		public TypeTree[] getChilds(){
			return this.childs;
		}
		
		/* Getter method for the single child */
		public TypeTree getChild(int pos) {
			return this.childs[pos];
		}
		
		/* 
		 * Method for Type Widening
		 * This Method is asymmetric: it takes the first type and tries to upcast it into the second one
		 * Params: String typeName1, typeName2 - the types to be compared
		 * Returns: The resulting widened type (null if widening is not possible) //TODO
		 */
		public static String widen(String typeName1, String typeName2) {
			String res = null;
			if (typeName1.equals(typeName2)) res = typeName1;
			else if (typeName1.equals("Int") && typeName2.equals("Double")) res = "Double";
			return res;
		}
		
		/* Method that checks Subtyping
		 * In Haskell, Type Hierarchy is not defined; instead, Hierarchy is represented by Typeclasses
		 * and their relationship.
		 * In this version of the Language, Typeclasses are not supported, so it is defined a simple
		 * Type Hierarchy where:
		 * - Any represents Type Variables (i.e. Java Generics)
		 * - Int is a subtype of Double
		 * The widen Method checks Subtyping for the single TreeNode
		 * Params: TypeTree other - the tree to be compared with the calling one
		 * Returns: Boolean - true if other is Parent of this, false otherwise
		 */
		public boolean isSubtype(TypeTree other) {
			boolean isSubtype = true;
			if (other.getTypeName().equals("error")) return false;
			if (other.getTypeName().equals("Any")) return true;
			if (TypeTree.widen(this.getTypeName(), other.getTypeName()) == null) return false;
			if (this.getChilds().length != other.getChilds().length) return false;
			for (int i = 0; i < this.getChilds().length; i++) {
				isSubtype = isSubtype && this.getChild(i).isSubtype(other.getChild(i));
			}
			return isSubtype;
		}
		
		/* 
		 * Method for Type Equivalence Checking
		 * The isSubtype relationship is a Partial Ordering Relation, 
		 * Type Equivalence is equivalent to checking that 
		 * the first type is a subtype of the second one and viceversa.
		 * Params: TypeTree other - the Tree to compare with the calling one
		 * Returns: Boolean - true if the Trees are equivalent, false otherwise
		 */
		 
		public boolean isEquivalent(TypeTree other) {	
			return this.isSubtype(other) && other.isSubtype(this);
		}
		
		/*
		 * Static TypeMap that contains all the declared Types (allows to define custom Data Types), which is initialized during Parser initialization
		 */
		private static HashMap<String, TypeTree> typeMap = new HashMap<>();
		
		/*
		 * Create TypeMap with the predefined available Types
		 * Params: nothing
		 * Return: nothing
		 */
		private static void createTypeMap() {
			// childTypeTree is used only for making the code slightly more readable
			TypeTree tree = new TypeTree("Int", new TypeTree[0]);
			TypeTree.addType(tree.getTypeName(), tree);
			tree = new TypeTree("Double", new TypeTree[0]);
			TypeTree.addType(tree.getTypeName(), tree);
			tree = new TypeTree("Bool", new TypeTree[0]);
			TypeTree.addType(tree.getTypeName(), tree);
			tree = new TypeTree("Char", new TypeTree[0]);
			TypeTree.addType(tree.getTypeName(), tree);
			TypeTree[] treeArray = { new TypeTree(tree) };
			tree = new TypeTree("List", treeArray);
			TypeTree.addType("String", tree);
			TypeTree anyTypeTree = new TypeTree("Any", new TypeTree[0]); 
			treeArray = new TypeTree[]{ new TypeTree(anyTypeTree) };
			tree = new TypeTree("List", treeArray);
			TypeTree.addType(tree.getTypeName(), tree);
			treeArray = new TypeTree[]{ new TypeTree(anyTypeTree), new TypeTree(anyTypeTree) };
			tree = new TypeTree("Function", treeArray);
			TypeTree.addType(tree.getTypeName(), tree);
			// special error type for propagating type checking errors
			tree = new TypeTree("error", new TypeTree[0]);
			TypeTree.addType(tree.getTypeName(), tree);
			// Min Arity for Tuples = 2, Max Arity for Tuples = 10
			/*for (int i = 2; i <= 10; i++) {
				treeArray = new TypeTree[i];
				for (int j = 0; j < i; j++) {
					treeArray[j] = new TypeTree(anyTypeTree);
				}	
				tree = new TypeTree("Tuple" + i, treeArray); 
				TypeTree.addType(tree.getTypeName(), tree);
			}*/
		}
		
		/* 
		 * Insert a new Type inside the typeMap (if already present, the new one is discarded and a Semantic Error should arise)
		 * Params: String typeName - the name of the new Type
		 * 		   TypeTree tree - the corresponding type 
		 * Return: boolean - true if no error occured, false otherwise
		 */
		public static boolean addType(String typeName, TypeTree tree) {
			if (typeMap.containsKey(typeName)) return false;
			typeMap.put(typeName, tree);
			return true;
		}
		
		/* 
		 * Check whether a certain type has been defined or not
		 * @param: String typeName - the type to look for
		 * @return: boolean - true if the type exists, false otherwise
		 */
		public static boolean typeExists(String typeName) {
			return typeMap.containsKey(typeName);
		}
		
		/* 
		 * Retrieve a clone of the TypeTree of a specific type from the typeMap, if present
		 * Params: String typeName - the name of the Type
		 * Return: the corresponding typeTree if the Type exists, null otherwise
		 */
		public static TypeTree getTypeTree(String typeName) {
			if (typeMap.containsKey(typeName))
				return new TypeTree(typeMap.get(typeName));
			else return null;
		}
		
		/*
		 * Debugging method for dumping the whole TypeMap TODO
		 * Params: nothing
		 * Returns: nothing
		 */
		public static void dumpTypeMap(){
			System.out.println("DEBUG: PRINTING TYPEMAP!");
			typeMap.forEach
				( (k, v) -> {
					System.out.println("TopTypeName: " + k);
					v.dumpTypeTree(0);
				} );
		}
		
		/*
		 * Debugging method for dumping a single TypeTree TODO
		 * Params: int level - defines the level inside the TypeTree, used for hierarchical printing of the Tree
		 * Returns: nothing
		 */
		private void dumpTypeTree(int level){
			for (int i = 0; i < level; i++)
				System.out.print("\t");
			System.out.println("-> " + this.getTypeName());
			for (int i = 0; i < this.getChilds().length; i++) {
				this.getChild(i).dumpTypeTree(level+1);
			}
		}
		
		/* 
		 * Being the project not originally developed using an IDE, using JUnit is not the best option
		 * It would be ideal to move testing there (TODO)
		 */
		public static void testTypeTree() {
			// Check TypeTree(TypeTree tree)
			// 		 isEquivalent, isSubtype
			TypeTree tree1 = TypeTree.getTypeTree("List");
			TypeTree tree2 = new TypeTree(tree1);
			if (tree1.isEquivalent(tree2))
				System.out.println("TEST TYPE TREE 1: PASSED");
			else
				System.out.println("TEST TYPE TREE 1: FAILED");
			// Check isSubtype, setChild, getTypeTree
			TypeTree tree3 = TypeTree.getTypeTree("List");
			tree3.setChild(0, TypeTree.getTypeTree("Int"));
			if (tree3.isSubtype(tree1))
				System.out.println("TEST TYPE TREE 2: PASSED");
			else
				System.out.println("TEST TYPE TREE 2: FAILED");
			TypeTree tree4 = TypeTree.getTypeTree("Int");
			TypeTree tree5 = TypeTree.getTypeTree("Double");
			if (tree4.isSubtype(tree5) && !tree5.isSubtype(tree4))
				System.out.println("TEST TYPE TREE 3: PASSED");
			else
				System.out.println("TEST TYPE TREE 3: FAILED");
		}
	}
	
	/* Class for the Symbol Table Stack
	 * The following Class contains a Static instance of the SymTable Stack, together with methods
	 * that allow to push/pop SymTables and to extract an Entry from them
	 * Fields: symTableStack - the Static instance of the SymTable Stack
	 */
	
	public static class SymTableStack {
		
		/* Class for Symbol Table Entry
		 * All Entries inside any SymTable are instances of this Class
		 * Fields: TypeTree tree - type of the value/function
		 *		   boolean isAssigned - flag that checks whether the value/function has been assigned or not
		 */
		private static class SymTableEntry {
			
			private TypeTree tree;
			private boolean isAssigned = false;
			
			/* TODO UNCOMMENT WHEN GENERATING IR
			// corresponding name in the intermediate representation
			String llvm;
			*/
			
			SymTableEntry(TypeTree tree) {
				this.tree = tree;
				this.isAssigned = false;
			}
			
			public TypeTree getTypeTree() {
				return this.tree;
			}
			
			public boolean getIsAssigned() {
				return this.isAssigned;
			}
			
			public void setTypeTree(TypeTree tree) {
				this.tree = tree;
			}
			
			public void setIsAssigned(boolean isAssigned) {
				this.isAssigned = isAssigned;
			}
		}
		
		
		// Symbol Table Stack (there is only one global instance whose lifetime corresponds to the lifetime of the parser itself)
		private static LinkedList<HashMap<String, SymTableEntry>> symTableStack = new LinkedList<>();
		
		/* 
		 * Method that pushes a new SymTable to the Stack
		 * Params: nothing
		 * Return: nothing
		 */
		public static void pushSymTable() {
			symTableStack.push(new HashMap<String, SymTableEntry>());
		}
		
		/* 
		 * Method that pops the SymTable on top of the Stack
		 * Params: nothing
		 * Return: nothing
		 */
		public static void popSymTable() {
			symTableStack.pop();
		}
		
		/*
		 * 
		 */
		public static HashMap<String, SymTableEntry> peekSymTable() {
			return symTableStack.peek();
		}
		
		/*
		 * Insert a new Entry in the SymTable on top of the Stack
		 * This method is sensitive to the context (it depends on the current position in the Parser Tree)
		 * The Parser must guarantee the correct SymTable for a given Entry
		 * Params: String id - the name of the Entry (the corresponding token)
		 * 		   SymTableEntry entry - the Entry
		 * Return: nothing
		 */
		public static void putEntry(String id, SymTableEntry entry) {
			symTableStack.peek().put(id, entry);
		}
		
		/*
		 * Check whether a certain Entry is present in the whole SymTable Stack
		 * Search is applied from the top of the Stack to the bottom;
		 * the first match is considered
		 * Params: String id - the name of the Entry (the corresponding token)
		 * Return: the flag that indicates whether the Entry is present or not
		 */
		public static boolean containsEntry(String id) {
			boolean entryFound = false; // flag, raised if an Entry having the same name as id is found
			Iterator<HashMap<String, SymTableEntry>> iterator = symTableStack.listIterator(0);
			while (!entryFound && iterator.hasNext()) {
				if (iterator.next().containsKey(id)) entryFound = true;
			}
			return entryFound;
		}
		
		/*
		 * Check whether a certain Entry is present in the whole SymTable Stack and return it
		 * Search is applied from the top of the Stack to the bottom;
		 * the first match is considered
		 * Params: String id - the name of the Entry (the corresponding token)
		 * Return: the Entry itself, if found (null otherwise)
		 */
		public static SymTableEntry getEntry(String id) {
			Iterator<HashMap<String, SymTableEntry>> iterator = symTableStack.listIterator(0);
			while (iterator.hasNext()) {
				HashMap<String, SymTableEntry> currentSymTable = iterator.next();
				if (currentSymTable.containsKey(id)) return currentSymTable.get(id);
			}
			return null;
		}
		
		/*
		 * Check whether a certain Entry is present in the whole SymTable Stack and return its TypeTree
		 * Search is applied from the top of the Stack to the bottom;
		 * the first match is considered
		 * Params: String id - the name of the Entry (the corresponding token)
		 * Return: the TypeTree of the Entry itself, if found (null otherwise)
		 */
		/*public static TypeTree getEntryTypeTree(String id) {
			SymTableEntry entry = SymTableStack.getEntry(id);
			if (debug_mode) System.err.println("WARNING: Inside getEntryTypeTree - no Entry found for " + id);
			return entry == null? null : entry.getTypeTree();
		}*/
		
		/*
		 * Check whether a certain Entry is present in the whole SymTable Stack and check if it has been already assigned
		 * Search is applied from the top of the Stack to the bottom;
		 * the first match is considered
		 * Params: String id - the name of the Entry (the corresponding token)
		 * Return: a Boolean flag indicating whether the variable has been assigned, null if the Entry has not been found
		 */
		/*public static Boolean getEntryAssignFlag(String id) {
			SymTableEntry entry = SymTableStack.getEntry(id);
			if (debug_mode) System.err.println("WARNING: Inside getEntryAssignFlag - no Entry found for " + id);
			return entry == null? null : entry.getIsAssigned();
		} */
		
		/*
		 * Debugging method that prints out the content of the whole symTableStack 
		 * Params: nothing
		 * Returns: nothing
		 */
		public static void dumpSymTableStack(){
			int level = 0;
			Iterator<HashMap<String, SymTableEntry>> iterator = symTableStack.listIterator(0);
			System.out.println("DEBUG: PRINTING SYMTABLESTACK!");
			while (iterator.hasNext()){
				System.out.println("Level " + level);
				iterator.next().forEach
					( (k, v) -> { 
						System.out.print("->");
						System.out.print(" Name: " + k);
						System.out.println(", isAssigned: " + v.getIsAssigned());
						v.getTypeTree().dumpTypeTree(1);
					});
				level++;
			}
		}
		
		/* 
		 * Being the project not originally developed using an IDE, using JUnit is not the best option
		 * It would be ideal to move testing there (TODO)
		 */
		public static void testSymTableStack() {
			SymTableStack.pushSymTable();
			TypeTree tree = TypeTree.getTypeTree("Int");
			SymTableStack.putEntry("x", new SymTableEntry(tree));
			SymTableStack.putEntry("y", new SymTableEntry(tree));
			if (SymTableStack.containsEntry("x")) 
				System.out.println ("TEST SYMTABLE STACK 1: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 1: FAILED");
			if (!SymTableStack.containsEntry("xx")) 
				System.out.println ("TEST SYMTABLE STACK 2: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 2: FAILED");
			if (SymTableStack.getEntry("x") != null)
				System.out.println ("TEST SYMTABLE STACK 3: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 3: FAILED");
			if (SymTableStack.getEntry("xx") == null) 
				System.out.println ("TEST SYMTABLE STACK 4: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 4: FAILED");
			boolean isPresent = SymTableStack.getEntry("x").getIsAssigned();
			if (!isPresent)
				System.out.println ("TEST SYMTABLE STACK 5: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 5: FAILED");
			SymTableStack.pushSymTable();
			TypeTree xTree = TypeTree.getTypeTree("Double");
			SymTableStack.putEntry("x", new SymTableEntry(xTree));
			SymTableEntry entry = SymTableStack.getEntry("x");
			if (entry != null && entry.getTypeTree().isEquivalent(TypeTree.getTypeTree("Double")))
				System.out.println ("TEST SYMTABLE STACK 6: PASSED");
			else
				System.out.println ("TEST SYMTABLE STACK 6: FAILED");
 			SymTableStack.popSymTable();
		}
		
	}
	
	
	/*
	 * Method that implements Uniqueness check, i.e. verifies whether a variable has already been declared in
	 * currentSymTable or not
	 * @param: String entryName - the name of the value whose uniqueness needs to be checked
	 * @return: boolean - true if the value is unique, false otherwise
	 */
	public boolean isUnique(String entryName) {
		return !SymTableStack.peekSymTable().containsKey(entryName);
	}
	
	/*
	 * Method that implements Assignment Uniqueness check, i.e. verifies whether a variable has already been assigned
	 * @param: String entryName - the name of the value whose assignment uniqueness needs to be checked
	 * @return: boolean - true if the value has not been assigned yet, false otherwise
	 */
	public boolean isNotAssigned(String entryName) {
		return !SymTableStack.getEntry(entryName).getIsAssigned();
	}
	
	/*
	 * Method that implements Arity check, i.e. verifies whether the function has the same arity of its actual arguments
	 * @param:  String funcName - the name of the function whose arity needs to be checked
	 * 			int arity - the expected arity of the function
	 * @return: boolean - true if the function has the same Arity, false otherwise
	 */
	public boolean hasArity(String funcName, int arity) {
		int count = 0;
		TypeTree funcTypeTree = SymTableStack.getEntry(funcName).getTypeTree();
		TypeTree rightChildTypeTree = funcTypeTree.getChild(1);
		while(rightChildTypeTree.getTypeName().equals("Function")) {
			rightChildTypeTree = funcTypeTree.getChild(1);
		}
		return count == arity;
	}
	
	/* 
	 * Method that implements Declaration check, i.e. verifies whether a variable has been declared in the whole program,
	 * since LHC supports Static Lexical Scoping
	 * @param: String entryName - the name of the value whose declaration needs to be checked
	 * @return: boolean - true if the value has been already declared, false otherwise
	 */
	public boolean isDeclared(String entryName) {
		return SymTableStack.containsEntry(entryName);
	}
	
	/*
	 * ALL THE FOLLOWING CLASSES ARE USED FOR SEMANTIC ANALYSIS (info for the AST) and IR CODEGEN
	 */
	
	public static class ConstantAST<V> {
		public V value;
		
		ConstantAST(V value) {
			this.value = value;
		}
	}
	
	public static class ExprAST {
		public TypeTree tree;
		
		ExprAST (TypeTree tree) {
			this.tree = tree;
		}
	}
	
	public static class SeqExprAST {
		// Type is inferred by the ExprAST
		public ExprAST[] exprArray;
		
		SeqExprAST (ExprAST[] exprArray) {
			this.exprArray = exprArray;
		}
	}
	
	public static class LExprAST extends SeqExprAST {
		public TypeTree tree;
		
		LExprAST (ExprAST[] exprArray, TypeTree tree) {
			super(exprArray);
			this.tree = tree;
		}
	}
	
	public static class LFormArgAST {
		public LinkedList<String> argList;
		
		LFormArgAST (LinkedList<String> argList) {
			this.argList = argList;
		}
	}
	
	public static class LActArgAST {
		public LinkedList<ActArgAST> actArgList;
		
		LActArgAST (LinkedList<ActArgAST> actArgList) {
			this.actArgList = actArgList;
		}
	}
	
	public static class ActArgAST {
		public TypeTree tree;

		ActArgAST (TypeTree tree) {
			this.tree = tree;
		}
	}
	
	public static class LetBlockAST {
		public TypeTree tree;
		
		LetBlockAST (TypeTree tree) {
			this.tree = tree;
		}
	}
	
	public static class IfBlockAST {
		public TypeTree tree;
		
		IfBlockAST (TypeTree tree) {
			this.tree = tree;
		}
	}
	
	public static class DeclTypeAST {
		public TypeTree tree;
		
		DeclTypeAST (TypeTree tree) {
			this.tree = tree;
		}
	}
	
	/* Value is:
	 * 		- LinkedList for lists
	 *		- Tuple for tuples
	 *		- Basic type for basic types (Int, Double, Char, String, Bool)
	 */
	public static class ValueAST {
		public TypeTree tree;
		public Object value;
		
		ValueAST (TypeTree tree, Object value) {
			this.tree = tree;
			this.value = value;
		}
	}
	
:};

/*  In the Initialization Section, the typeMap (i.e. the list containing all declared types) is filled 
 *  with all the main Basic and Compound Types. 
 *  The only exception are Tuples, whose Type corresponds to the combination of the types of its elements;
 *  since such a Type would need too much space inside the typeMap, it is the ONLY Type that is not saved in the typeMap;
 *  so, it must be handled with specific procedures
 *  The "Any" Type acts as a wildcard and represents any possible Type (it represents Type Parameters)
 *  
 *  TODO Aggiungere metodi head, tail, size (per Liste), extract (per Tuple) nella symTable globale
 */
init with {:
		
		// Create the Table containing all Types and their TypeTrees
		CUP$Parser$actions.TypeTree.createTypeMap();
		
		//CUP$Parser$actions.TypeTree.dumpTypeMap();
		//CUP$Parser$actions.TypeTree.testTypeTree();
		//CUP$Parser$actions.SymTableStack.testSymTableStack();
:}

/* Because of a bug in JavaCupMainDrawTree, the "scan with" directive does not substitute the default call to next_token as expected.
 * Instead, the user code is just inserted before the aforementioned call, preventing the user from customizing 
 * the scanning method (an "Unreachable statement" compiler error arises). 
 * For this reason, it is necessary to manually force the user code execution
 * This is the reason behind the fake conditional statement below
 */
scan with {:   
		if (true) {
			Scanner scanner = (Scanner) this.getScanner();
			Symbol s = scanner.next_token_custom(); 
			Tree.push(s.toString(), 0); // necessary to build the graphical Parsing Tree
			return s;
		}	
:}

/// ///////////////////////// ///
///	  TERMINALS (lowercase)   ///
/// ///////////////////////// ///

terminal main;
terminal eq, clns, cm, ro, rc, bo, bc, arrow, sep/*, us */;
terminal plus, minus, times, div, intdiv, mod, uminus, and, or, not;
terminal head, tail, elem, index;
terminal releq, relge, relgt, relle, rellt;
terminal conc, cons;
terminal indent, dedent;
//terminal where, pipe;
terminal do_begin, if_begin, then, else_begin, let, in, print;
terminal ConstantAST<Integer> val_int;
terminal ConstantAST<Double> val_double;
terminal ConstantAST<Boolean> val_bool;
terminal ConstantAST<Char> val_char;
terminal ConstantAST<String> val_string;
terminal type_int, type_double, type_bool, type_char, type_string;
terminal String id;

/// ///////////////////////// ///
///	NON TERMINALS (uppercase) ///
/// ///////////////////////// ///

non terminal PROGRAM;
non terminal FUNCT_PART, IMPER_PART;
non terminal IO_ACTIONS, IO_ACTION;
non terminal PRINT;
non terminal ExprAST COND, EXPR, EXPR_NOTUNARYOP;
non terminal LExprAST LEXPR;
non terminal ActArgAST ACTARG;
non terminal LActArgAST LACTARG;
non terminal LFormArgAST LFORMARG;
//non terminal WHERE, WHERE_STMTS, GUARDS, GUARD;
non terminal LET_STMTS;
non terminal DO_BLOCK;
non terminal LetBlockAST LET_BLOCK_FUNC;
non terminal LET_BLOCK_IMPER;
non terminal IfBlockAST IF_BLOCK_FUNC;
non terminal IF_BLOCK_IMPER;
non terminal DECL, DECL_VALUE, DECL_FUNCT;
non terminal DeclTypeAST DECL_TYPE;
non terminal TypeTree TYPE, TYPE_VALUE, TYPE_FUNC, TYPE_LIST, TYPE_BASIC;
//non terminal LinkedList<TypeTree> TTYPE_VALUE;
non terminal ValueAST VALUE, VALUE_LIST, VALUE_BASIC;
//non terminal PATTERN, LPATTERN_CM, LPATTERN_CONS;
//non terminal PATTERN_LIST, PATTERN_TUPLE;

/// ///////////////////////// ///
///    PRECEDENCE RULES		  ///
/// ///////////////////////// ///

precedence left conc;
precedence right cons;
precedence left or;
precedence left and;
precedence nonassoc releq, relgt, relge, rellt, relle;
precedence left plus, minus;
precedence left times, div, intdiv;
precedence right index;
precedence nonassoc not, uminus;

start with PROGRAM;

/// ///////////////////////// ///
///	   PRODUCTION RULES       ///
/// ///////////////////////// ///
 
PROGRAM ::= /* empty program */ 
			{:
				if (noCompileErrors) {
				System.out.println("CODE COMPILED SUCCESSFULLY");
				}
			:}
		  | indent
			{:	// push the top-level symtable
				SymTableStack.pushSymTable();
				if (debug_mode) System.out.println("DEBUG: Top-level Symtable pushed");
			:}
			FUNCT_PART IMPER_PART {:
					SymTableStack.popSymTable();
					if (debug_mode) System.out.println("DEBUG: Top-level Symtable popped");
				:}
			dedent {:  // pop the top-level symtable
					if (noCompileErrors) {
						System.out.println("CODE COMPILED SUCCESSFULLY");
					}	
				:}
;

/// ////////////////// ///
///  IMPERATIVE PART   ///
/// ////////////////// ///

IMPER_PART ::= main eq IO_ACTION
;

IO_ACTION ::= PRINT
            | DO_BLOCK
			| IF_BLOCK_IMPER
;

IO_ACTIONS ::= IO_ACTION
			 | IO_ACTIONS sep IO_ACTION
			 | LET_BLOCK_IMPER
;

PRINT ::= print ACTARG
;

DO_BLOCK ::= do_begin indent IO_ACTIONS dedent
;

IF_BLOCK_IMPER ::= if_begin COND:cond then IO_ACTION else_begin IO_ACTION
				{:
					if (!cond.tree.isEquivalent(TypeTree.getTypeTree("Bool"))) {
						report_semantic_error("Wrong Type (Expected Type: Bool)");
					}
				:}
;

LET_BLOCK_IMPER ::= let {:
						SymTableStack.pushSymTable();
						if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable pushed");
					:}
					indent LET_STMTS dedent IO_ACTION {:
						SymTableStack.popSymTable();
						if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable popped");
					:}
;
// DECL_FUNCT not supported (for now)
LET_STMTS ::= LET_STMTS sep DECL_TYPE
			| LET_STMTS sep DECL_VALUE
			| DECL_TYPE
			| DECL_VALUE
;

/// ////////////////// ///
///  FUNCTIONAL PART   ///
/// ////////////////// ///
 
FUNCT_PART ::= /* empty Functional section */
			 | FUNCT_PART DECL sep
;

/* special expression management for boolean conditions */
COND ::= EXPR:expr {:
					if (!expr.tree.isEquivalent(TypeTree.getTypeTree("Bool"))) {
						report_semantic_error("Wrong Type (Expected Type: Bool)");
						RESULT = new ExprAST(TypeTree.getTypeTree("error"));
					}
					else {
						RESULT = new ExprAST(TypeTree.getTypeTree("Bool"));
					}
			   :}
;

///  DECLARATIONS  ///

DECL ::= DECL_TYPE
	   | DECL_VALUE
	   | DECL_FUNCT;

DECL_TYPE ::= id:id cm DECL_TYPE:decl_type
			{:
				TypeTree tree = new TypeTree(decl_type.tree);
				if (isUnique(id)) {
					SymTableStack.putEntry(id, new SymTableStack.SymTableEntry(tree));
				}
				else {
					report_semantic_error("Multiple Value Declaration (Symbol " + id + ")");
				}
				RESULT = new DeclTypeAST(new TypeTree(tree));
			:}
			| id:id clns TYPE:type
			{:
				TypeTree tree = new TypeTree(type);
				if (isUnique(id)) {
					SymTableStack.putEntry(id, new SymTableStack.SymTableEntry(tree));
				}
				else {
					report_semantic_error("Multiple Value Declaration (Symbol " + id + ")");
				}
				RESULT = new DeclTypeAST(new TypeTree(tree));
			:}
; 

/* pattern and expr should be of the same type */
//DECL_VALUE ::= PATTERN eq EXPR
DECL_VALUE ::= id:id eq EXPR:expr
			{:
				if (isDeclared(id) && (isNotAssigned(id)) && (expr.tree.isEquivalent(SymTableStack.getEntry(id).getTypeTree()))) {
					SymTableStack.getEntry(id).setIsAssigned(true);
				}
				else {
					if (!isDeclared(id)) {
						report_semantic_error("Missing Value Declaration (Symbol " + id + ")");
					}
					else if (!isNotAssigned(id)) {
						report_semantic_error("Multiple Value Assignment (Symbol " + id + ")");
					}
					else {
						report_semantic_error("Mismatching Type on Assignment (involving Symbol " + id + ")"); 
					}
				}
			:}
			// The Empty List can be used only here
			|  id:id eq bo bc 
			{:
				if (isDeclared(id) && (isNotAssigned(id)) && 
						(SymTableStack.getEntry(id).getTypeTree().isSubtype(TypeTree.getTypeTree("List")))) {
					SymTableStack.getEntry(id).setIsAssigned(true);
				}
				else {
					if (!isDeclared(id)) {
						report_semantic_error("Missing Value Declaration (Symbol " + id + ")");
					}
					else if (!isNotAssigned(id)) {
						report_semantic_error("Multiple Value Assignment (Symbol " + id + ")");
					}
					else {
						report_semantic_error("Mismatching Type on Assignment (involving Symbol " + id + ")"); 
					}
				}
			:}
;

/* no nullary functions */
DECL_FUNCT ::= id {: 
					SymTableStack.pushSymTable();
					if (debug_mode) System.out.println("DEBUG: Function Declaration - Symtable pushed");
			   :}
			   LFORMARG eq 
			   EXPR {:
					SymTableStack.popSymTable();
					if (debug_mode) System.out.println("DEBUG: Function Declaration - Symtable popped");
			   :}  
			    //WHERE
;

/* GUARDS ::= GUARDS sep GUARD
         | GUARD
;

   GUARD ::= pipe COND eq EXPR
; */

/* WHERE ::= // no where section 
        | where indent WHERE_STMTS dedent
; 

   WHERE_STMTS ::= WHERE_STMTS sep DECL 
			  | DECL
;*/

///  PATTERN MATCHING   ///

/*LFORMARG ::= LFORMARG PATTERN
		   | PATTERN
;

PATTERN ::= PATTERN_LIST
		  | PATTERN_TUPLE
		  | VALUE_BASIC
		  | us
		  | id
;

PATTERN_LIST ::= ro PATTERN cons LPATTERN_CONS rc // value constructor pattern
			   | bo LPATTERN_CM bc	// value pattern
			   | bo bc
;

LPATTERN_CONS ::= PATTERN
				| PATTERN cons LPATTERN_CONS
;

PATTERN_TUPLE ::= ro PATTERN cm LPATTERN_CM rc
				| ro rc
;

LPATTERN_CM ::= PATTERN
			  | PATTERN cm LPATTERN_CM
; */

LFORMARG ::= LFORMARG id
		   | id
;

///   EXPRESSIONS   ///

EXPR ::= EXPR plus EXPR_NOTUNARYOP
	   | EXPR minus EXPR_NOTUNARYOP
	   | EXPR times EXPR_NOTUNARYOP
	   | EXPR div EXPR_NOTUNARYOP
	   | EXPR intdiv EXPR_NOTUNARYOP
	   | mod ACTARG ACTARG 
	   | EXPR and EXPR_NOTUNARYOP
	   | EXPR or EXPR_NOTUNARYOP
	   | EXPR releq EXPR_NOTUNARYOP
	   | EXPR relgt EXPR_NOTUNARYOP
	   | EXPR relge EXPR_NOTUNARYOP
	   | EXPR rellt EXPR_NOTUNARYOP
	   | EXPR relle EXPR_NOTUNARYOP
	   | head ACTARG
	   | tail ACTARG
	   | elem ACTARG
	   | EXPR index EXPR
	   | EXPR cons EXPR_NOTUNARYOP
	   | EXPR conc EXPR_NOTUNARYOP
	   | ro EXPR rc
	   | not EXPR   
	   | minus EXPR 		%prec uminus 
	   | LET_BLOCK_FUNC
	   | IF_BLOCK_FUNC
	   | id LACTARG 
	   | VALUE
;

EXPR_NOTUNARYOP ::= 
		 EXPR_NOTUNARYOP plus EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP minus EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP times EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP div EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP intdiv EXPR_NOTUNARYOP
	   | mod ACTARG ACTARG 
	   | EXPR_NOTUNARYOP and EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP or EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP releq EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP relgt EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP relge EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP rellt EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP relle EXPR_NOTUNARYOP
	   | head ACTARG
	   | tail ACTARG
	   | elem ACTARG
	   | EXPR_NOTUNARYOP index EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP cons EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP conc EXPR_NOTUNARYOP
	   | ro EXPR rc
	   | LET_BLOCK_FUNC
	   | IF_BLOCK_FUNC
	   | id LACTARG 
	   | VALUE
;

LET_BLOCK_FUNC ::= 	let {:
						SymTableStack.pushSymTable();
						if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable pushed");
					:} 
					indent LET_STMTS dedent in EXPR {:
						SymTableStack.popSymTable();
						if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable popped");
					:}
;


IF_BLOCK_FUNC ::= if_begin COND then EXPR else_begin EXPR
;


///    args for function call   ///

ACTARG ::= id 
         | VALUE
		 | ro EXPR rc
;

// list of input arguments for function call
LACTARG ::= /* empty list of args: we call a variable */
		  | LACTARG ACTARG
;

///   VALUES   ///

VALUE ::= VALUE_BASIC
		| VALUE_LIST
//		| VALUE_TUPLE
;

VALUE_BASIC ::= val_int
			  | val_double
			  | val_bool
			  | val_char
			  | val_string
;

// Empty List can only be directly used in declaration, to avoid Type Variables propagation
VALUE_LIST ::= bo LEXPR bc
;

//VALUE_TUPLE ::= ro TEXPR rc
//;

LEXPR ::= EXPR
		| LEXPR cm EXPR
;

//TEXPR ::= EXPR cm EXPR
//		| TEXPR cm EXPR
//;

///   TYPES   ///

TYPE ::= TYPE_VALUE
	   | TYPE_FUNC
;

// both basic types and compound
TYPE_VALUE ::= TYPE_LIST
			 | TYPE_BASIC
//			 | TYPE_TUPLE
;

TYPE_BASIC ::= type_int
			 | type_double
			 | type_bool
			 | type_char
			 | type_string
;

TYPE_LIST ::= bo TYPE_BASIC bc
;

//TYPE_TUPLE ::= ro TTYPE_VALUE rc
//;

// no higher order functions
TYPE_FUNC ::= TYPE_VALUE arrow TYPE_FUNC
		    | TYPE_VALUE arrow TYPE_VALUE
;

// 0-Tuple are not allowed
//TTYPE_VALUE ::= TYPE_VALUE cm TYPE_VALUE
//			  | TTYPE_VALUE cm TYPE_VALUE
//;



