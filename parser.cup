import java_cup.runtime.*;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Stack;

parser code {:

	private String outputFileName;

	public boolean noCompileErrors = true;
	
	public void setOutputFileName(String outputFileName) {
		this.outputFileName = outputFileName;
	}
	
	public void syntax_error(java_cup.runtime.Symbol current) {
		report_error(current);
	}
	
    public void report_error(Object info) {
        System.err.print("ERROR: Syntax error");
		noCompileErrors = false;
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left);
                int column = (((Symbol)info).right);
                System.err.print(" (line "+line+", column "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
	
:};

action code {:

	boolean debug_mode = true; // only to print debug information
	
	private class TypeTree {
		
	}
	
	//private ArrayList<PatternTree> patternArray;
	
	private static class SymTableStack {
		
		// Class for Symbol Table Entry
		private static class SymTableEntry {
			// type of the value/function
			TypeTree tree;
			// flag for the Assignment Uniqueness Check
			boolean isAssigned = false;
			/* TODO UNCOMMENT WHEN GENERATING IR
			// corresponding name in the intermediate representation
			String llvm;
			*/
			SymTableEntry(TypeTree tree) {
				this.tree = tree;
				this.isAssigned = false;
			}
		}
		
		// Symbol Table Stack
		private static LinkedList<HashMap<String, SymTableEntry>> symTableStack = new LinkedList<>();
		
		public static void pushSymTable() {
			symTableStack.push(new HashMap<String, SymTableEntry>());
		}
		
		public static void popSymTable() {
			symTableStack.pop();
		}
		
		public static void peekSymTable() {
			symTableStack.peek();
		}
		
		public static void putEntry(String id, TypeTree tree) {
			symTableStack.peek().put(id, new SymTableEntry(tree));
		}
		
		/*public static searchEntry() {
			// TODO to be written
		} */
		
	}

:};

/* Because of a bug in JavaCupMainDrawTree, the "scan with" directive does not substitute the default call to next_token as expected.
 * Instead, the user code is just inserted before the aforementioned call, preventing the user from customizing 
 * the scanning method (an "Unreachable statement" compiler error arises). 
 * For this reason, it is necessary to manually force the user code execution
 * This is the reason behind the fake conditional statement below
 */
scan with {:   if (true) {
					Scanner scanner = (Scanner) this.getScanner();
					Symbol s = scanner.next_token_custom(); 
					Tree.push(s.toString(), 0); // necessary to build the graphical Parsing Tree
					return s;
				}	:}

/// ///////////////////////// ///
///	  TERMINALS (lowercase)   ///
/// ///////////////////////// ///

terminal main;
terminal eq, clns, cm, ro, rc, bo, bc, arrow, sep/*, us */;
terminal plus, minus, times, div, mod, exp, uminus, and, or, not;
terminal releq, relge, relgt, relle, rellt;
terminal conc, cons;
terminal indent, dedent;
//terminal where, pipe;
terminal do_begin, if_begin, then, else_begin, let, in, print;
terminal val_int, val_double, val_bool, val_char, val_string;
terminal type_int, type_double, type_bool, type_char, type_string;
terminal id;

/// ///////////////////////// ///
///	NON TERMINALS (uppercase) ///
/// ///////////////////////// ///

non terminal PROGRAM;
non terminal FUNCT_PART, IMPER_PART;
non terminal IO_ACTIONS, IO_ACTION;
non terminal PRINT;
non terminal COND, EXPR, EXPR_NOTUNARYOP;
non terminal LEXPR, TEXPR;
non terminal ACTARG, LACTARG;
//non terminal WHERE, WHERE_STMTS, GUARDS, GUARD;
non terminal LET_STMTS;
non terminal DECL, DECL_TYPE, DECL_VALUE, DECL_FUNCT;
non terminal TYPE;
non terminal TYPE_VALUE, TYPE_FUNC;
non terminal TYPE_TUPLE, TYPE_LIST, TYPE_BASIC;
non terminal VALUE;
non terminal VALUE_LIST, VALUE_TUPLE, VALUE_BASIC;
non terminal TTYPE_VALUE;
//non terminal PATTERN, LPATTERN_CM, LPATTERN_CONS;
//non terminal PATTERN_LIST, PATTERN_TUPLE;
non terminal LFORMARG;

/// ///////////////////////// ///
///    PRECEDENCE RULES		  ///
/// ///////////////////////// ///

precedence left conc;
precedence right cons;
precedence left or;
precedence left and;
precedence nonassoc releq, relgt, relge, rellt, relle;
precedence left plus, minus;
precedence left times, div;
precedence right exp;
precedence nonassoc not, uminus;

start with PROGRAM;

/// ///////////////////////// ///
///	   PRODUCTION RULES       ///
/// ///////////////////////// ///
 
PROGRAM ::= /* empty program */ 
			{:
				if (noCompileErrors) {
				System.out.println("CODE COMPILED SUCCESSFULLY");
				}
			:}
		  | {:	// push the top-level symtable
				SymTableStack.pushSymTable();
				if (debug_mode) System.out.println("DEBUG: Top-level Symtable pushed");
			:}
			indent FUNCT_PART IMPER_PART {:
					SymTableStack.popSymTable();
					if (debug_mode) System.out.println("DEBUG: Top-level Symtable popped");
				:}
			dedent {:  // pop the top-level symtable
					if (noCompileErrors) {
						System.out.println("CODE COMPILED SUCCESSFULLY");
					}	
				:}
;

/// ////////////////// ///
///  IMPERATIVE PART   ///
/// ////////////////// ///

IMPER_PART ::= main eq indent IO_ACTION dedent
;

IO_ACTION ::= PRINT
            | do_begin indent IO_ACTIONS dedent
			| let {:
					SymTableStack.pushSymTable();
					if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable pushed");
				:}
			  indent LET_STMTS dedent IO_ACTION {:
					SymTableStack.popSymTable();
					if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable popped");
				:}
			| if_begin COND then IO_ACTION else_begin IO_ACTION
;

IO_ACTIONS ::= IO_ACTION
			 | IO_ACTIONS sep IO_ACTION
;

PRINT ::= print ACTARG
;

// DECL_FUNCT not supported (for now)
LET_STMTS ::= LET_STMTS sep DECL_TYPE
			| LET_STMTS sep DECL_VALUE
			| DECL_TYPE
			| DECL_VALUE
;

/// ////////////////// ///
///  FUNCTIONAL PART   ///
/// ////////////////// ///
 
FUNCT_PART ::= /* empty Functional section */
			 | FUNCT_PART DECL sep
;

/* special expression management for boolean conditions */
COND ::= EXPR 
;

///  DECLARATIONS  ///

DECL ::= DECL_TYPE
	   | DECL_VALUE
	   | DECL_FUNCT;

DECL_TYPE ::= id cm DECL_TYPE
			| id clns TYPE
; 

/* pattern and expr should be of the same type */
//DECL_VALUE ::= PATTERN eq EXPR
DECL_VALUE ::= id eq EXPR
;

/* no nullary functions */
DECL_FUNCT ::= id {: 
					SymTableStack.pushSymTable();
					if (debug_mode) System.out.println("DEBUG: Function Declaration - Symtable pushed");
			   :}
			   LFORMARG eq 
			   EXPR {:
					SymTableStack.popSymTable();
					if (debug_mode) System.out.println("DEBUG: Function Declaration - Symtable popped");
			   :}  
			    //WHERE
;

/* GUARDS ::= GUARDS sep GUARD
         | GUARD
;

   GUARD ::= pipe COND eq EXPR
; */

/* WHERE ::= // no where section 
        | where indent WHERE_STMTS dedent
; 

   WHERE_STMTS ::= WHERE_STMTS sep DECL 
			  | DECL
;*/

///  PATTERN MATCHING   ///

/*LFORMARG ::= LFORMARG PATTERN
		   | PATTERN
;

PATTERN ::= PATTERN_LIST
		  | PATTERN_TUPLE
		  | VALUE_BASIC
		  | us
		  | id
;

PATTERN_LIST ::= ro PATTERN cons LPATTERN_CONS rc // value constructor pattern
			   | bo LPATTERN_CM bc	// value pattern
			   | bo bc
;

LPATTERN_CONS ::= PATTERN
				| PATTERN cons LPATTERN_CONS
;

PATTERN_TUPLE ::= ro PATTERN cm LPATTERN_CM rc
				| ro rc
;

LPATTERN_CM ::= PATTERN
			  | PATTERN cm LPATTERN_CM
; */

LFORMARG ::= LFORMARG id
		   | id
;

///   EXPRESSIONS   ///

EXPR ::= EXPR plus EXPR_NOTUNARYOP
	   | EXPR minus EXPR_NOTUNARYOP
	   | EXPR times EXPR_NOTUNARYOP
	   | EXPR div EXPR_NOTUNARYOP
	   | mod ACTARG ACTARG 
	   | EXPR exp EXPR_NOTUNARYOP
	   | EXPR and EXPR_NOTUNARYOP
	   | EXPR or EXPR_NOTUNARYOP
	   | EXPR releq EXPR_NOTUNARYOP
	   | EXPR relgt EXPR_NOTUNARYOP
	   | EXPR relge EXPR_NOTUNARYOP
	   | EXPR rellt EXPR_NOTUNARYOP
	   | EXPR relle EXPR_NOTUNARYOP
	   | EXPR cons EXPR_NOTUNARYOP
	   | EXPR conc EXPR_NOTUNARYOP
	   | ro EXPR rc
	   | not EXPR   
	   | minus EXPR 		%prec uminus 
	   | let	{:
			SymTableStack.pushSymTable();
			if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable pushed");
		 :} 
		 indent LET_STMTS dedent in EXPR {:
			SymTableStack.popSymTable();
			if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable popped");
		 :}
	   | if_begin COND then EXPR else_begin EXPR
	   | id LACTARG 
	   | VALUE
;

EXPR_NOTUNARYOP ::= 
		 EXPR_NOTUNARYOP plus EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP minus EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP times EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP div EXPR_NOTUNARYOP
	   | mod ACTARG ACTARG 
	   | EXPR_NOTUNARYOP exp EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP and EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP or EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP releq EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP relgt EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP relge EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP rellt EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP relle EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP cons EXPR_NOTUNARYOP
	   | EXPR_NOTUNARYOP conc EXPR_NOTUNARYOP
	   | ro EXPR rc
	   | let {:
			SymTableStack.pushSymTable();
			if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable pushed");
		 :} 
		 indent LET_STMTS dedent in EXPR {:
			SymTableStack.popSymTable();
			if (debug_mode) System.out.println("DEBUG: Let Statement - Symtable popped");
		 :}
	   | if_begin COND then EXPR else_begin EXPR
	   | id LACTARG 
	   | VALUE
;

///    args for function call   ///

ACTARG ::= id 
         | VALUE
		 | ro EXPR rc
;

// list of input arguments for function call
LACTARG ::= /* empty list of args: we call a variable */
		  | LACTARG ACTARG
;

///   VALUES   ///

VALUE ::= VALUE_BASIC
		| VALUE_LIST
		| VALUE_TUPLE
;

VALUE_BASIC ::= val_int
			  | val_double
			  | val_bool
			  | val_char
			  | val_string
;

VALUE_LIST ::= bo LEXPR bc
			 | bo bc
;

VALUE_TUPLE ::= ro TEXPR rc 
			  | ro rc
;

LEXPR ::= EXPR
		| LEXPR cm EXPR
;

TEXPR ::= EXPR cm EXPR
		| TEXPR cm EXPR
;
///   TYPES   ///

TYPE ::= TYPE_VALUE
	   | TYPE_FUNC
;

// both basic types and compound
TYPE_VALUE ::= TYPE_TUPLE
			 | TYPE_LIST
			 | TYPE_BASIC
;

TYPE_BASIC ::= type_int
			 | type_double
			 | type_bool
			 | type_char
			 | type_string
;

TYPE_LIST ::= bo TYPE_VALUE bc
;

TYPE_TUPLE ::= ro rc 
			 | ro TTYPE_VALUE rc
;

// no higher order functions
TYPE_FUNC ::= TYPE_VALUE arrow TYPE_FUNC
		    | TYPE_VALUE arrow TYPE_VALUE
;

TTYPE_VALUE ::= TYPE_VALUE
			  | TTYPE_VALUE cm TYPE_VALUE
;



